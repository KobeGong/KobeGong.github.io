<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龚高锋的博客</title>
  <subtitle>Never Give Up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gonggaofeng.me/"/>
  <updated>2016-03-28T17:10:30.000Z</updated>
  <id>http://gonggaofeng.me/</id>
  
  <author>
    <name>龚高锋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity Trasition实现流程</title>
    <link href="http://gonggaofeng.me/2016/03/29/Activity-Trasition%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/"/>
    <id>http://gonggaofeng.me/2016/03/29/Activity-Trasition实现流程/</id>
    <published>2016-03-28T17:06:49.000Z</published>
    <updated>2016-03-28T17:10:30.000Z</updated>
    
    <content type="html">&lt;p&gt;自Android L系统发布后，Activity相关的动画API增加了好多，包括Explode, Slide等，这些动画都是在Transition框架之上运行的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Activity的PerformCreate函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final void performCreate(Bundle icicle) {
    onCreate(icicle);
    mActivityTransitionState.readState(icicle);
    performCreateCommon();
}
final void performCreateCommon() {
    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
                                  com.android.internal.R.styleable.Window_windowNoDisplay, false);
    mFragments.dispatchActivityCreated();
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;setEnterActivityOptions(Activity activity, ActivityOptions options)方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void setEnterActivityOptions(Activity activity, ActivityOptions options) &amp;#123;&amp;#10;        if (activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS)&amp;#10;                &amp;#38;&amp;#38; options != null &amp;#38;&amp;#38; mEnterActivityOptions == null&amp;#10;                &amp;#38;&amp;#38; mEnterTransitionCoordinator == null&amp;#10;                &amp;#38;&amp;#38; options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &amp;#123;&amp;#10;            mEnterActivityOptions = options;&amp;#10;            mIsEnterTriggered = false;&amp;#10;            if (mEnterActivityOptions.isReturning()) &amp;#123;&amp;#10;                restoreExitedViews();&amp;#10;                int result = mEnterActivityOptions.getResultCode();&amp;#10;                if (result != 0) &amp;#123;&amp;#10;                    activity.onActivityReenter(result, mEnterActivityOptions.getResultData());&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;framework/base/core/java/android/app/ActivityTransitionState.java&lt;/p&gt;
&lt;p&gt;Activity.performStart()&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;final void performStart() &amp;#123;&amp;#10;        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());&amp;#10;        mFragments.noteStateNotSaved();&amp;#10;        mCalled = false;&amp;#10;        mFragments.execPendingActions();&amp;#10;        mInstrumentation.callActivityOnStart(this);&amp;#10;        if (!mCalled) &amp;#123;&amp;#10;            throw new SuperNotCalledException(&amp;#10;                &amp;#34;Activity &amp;#34; + mComponent.toShortString() +&amp;#10;                &amp;#34; did not call through to super.onStart()&amp;#34;);&amp;#10;        &amp;#125;&amp;#10;        mFragments.dispatchStart();&amp;#10;        mFragments.reportLoaderStart();&amp;#10;        mActivityTransitionState.enterReady(this);&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;framework/base/core/java/android/app/Activity.java&lt;/p&gt;
&lt;p&gt;进入ActivityTransitionState.enterReady(Activity activity)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void enterReady(Activity activity) &amp;#123;&amp;#10;        if (mEnterActivityOptions == null || mIsEnterTriggered) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        mIsEnterTriggered = true;&amp;#10;        mHasExited = false;&amp;#10;        ArrayList&amp;#60;String&amp;#62; sharedElementNames = mEnterActivityOptions.getSharedElementNames();&amp;#10;        ResultReceiver resultReceiver = mEnterActivityOptions.getResultReceiver();&amp;#10;        if (mEnterActivityOptions.isReturning()) &amp;#123;&amp;#10;            restoreExitedViews();&amp;#10;            activity.getWindow().getDecorView().setVisibility(View.VISIBLE);&amp;#10;        &amp;#125;&amp;#10;        mEnterTransitionCoordinator = new EnterTransitionCoordinator(activity,&amp;#10;                resultReceiver, sharedElementNames, mEnterActivityOptions.isReturning());&amp;#10;&amp;#10;        if (!mIsEnterPostponed) &amp;#123;&amp;#10;            startEnter();&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果动画没有postponed,执行startEnter()方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void startEnter() &amp;#123;&amp;#10;        if (mEnterActivityOptions.isReturning()) &amp;#123;&amp;#10;            if (mExitingToView != null) &amp;#123;&amp;#10;                mEnterTransitionCoordinator.viewInstancesReady(mExitingFrom, mExitingTo,&amp;#10;                        mExitingToView);&amp;#10;            &amp;#125; else &amp;#123;&amp;#10;                mEnterTransitionCoordinator.namedViewsReady(mExitingFrom, mExitingTo);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            mEnterTransitionCoordinator.namedViewsReady(null, null);&amp;#10;            mEnteringNames = mEnterTransitionCoordinator.getAllSharedElementNames();&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        mExitingFrom = null;&amp;#10;        mExitingTo = null;&amp;#10;        mExitingToView = null;&amp;#10;        mEnterActivityOptions = null;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新启动的Activity, mEnterActivityOptions.isReturning()为false ,进入else。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void namedViewsReady(ArrayList&amp;#60;String&amp;#62; accepted, ArrayList&amp;#60;String&amp;#62; localNames) &amp;#123;&amp;#10;        triggerViewsReady(mapNamedElements(accepted, localNames));&amp;#10;    &amp;#125;&amp;#10;private void triggerViewsReady(final ArrayMap&amp;#60;String, View&amp;#62; sharedElements) &amp;#123;&amp;#10;        if (mAreViewsReady) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        mAreViewsReady = true;&amp;#10;        final ViewGroup decor = getDecor();&amp;#10;        // Ensure the views have been laid out before capturing the views -- we need the epicenter.&amp;#10;        if (decor == null || (decor.isAttachedToWindow() &amp;#38;&amp;#38;&amp;#10;                (sharedElements.isEmpty() || !sharedElements.valueAt(0).isLayoutRequested()))) &amp;#123;&amp;#10;            viewsReady(sharedElements);&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            decor.getViewTreeObserver()&amp;#10;                    .addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &amp;#123;&amp;#10;                        @Override&amp;#10;                        public boolean onPreDraw() &amp;#123;&amp;#10;                            decor.getViewTreeObserver().removeOnPreDrawListener(this);&amp;#10;                            viewsReady(sharedElements);&amp;#10;                            return true;&amp;#10;                        &amp;#125;&amp;#10;                    &amp;#125;);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void viewsReady(ArrayMap&amp;#60;String, View&amp;#62; sharedElements) &amp;#123;&amp;#10;        super.viewsReady(sharedElements);&amp;#10;        mIsReadyForTransition = true;&amp;#10;        hideViews(mSharedElements);&amp;#10;        if (getViewsTransition() != null &amp;#38;&amp;#38; mTransitioningViews != null) &amp;#123;&amp;#10;            hideViews(mTransitioningViews);&amp;#10;        &amp;#125;&amp;#10;        if (mIsReturning) &amp;#123;&amp;#10;            sendSharedElementDestination();&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            moveSharedElementsToOverlay();&amp;#10;        &amp;#125;&amp;#10;        if (mSharedElementsBundle != null) &amp;#123;&amp;#10;            onTakeSharedElements();&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这段代码主要有三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;hideView. 将mSharedElements中的view的alpha值设为0.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void hideViews(ArrayList&amp;#60;View&amp;#62; views) &amp;#123;&amp;#10;        int count = views.size();&amp;#10;        for (int i = 0; i &amp;#60; count; i++) &amp;#123;&amp;#10;            View view = views.get(i);&amp;#10;            if (!mOriginalAlphas.containsKey(view)) &amp;#123;&amp;#10;                mOriginalAlphas.put(view, view.getAlpha());&amp;#10;            &amp;#125;&amp;#10;            view.setAlpha(0f);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;moveSharedElementsToOverlay. 将mSharedElements的view添加到ViewOverlay。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void moveSharedElementsToOverlay() &amp;#123;&amp;#10;        if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        setSharedElementMatrices();&amp;#10;        int numSharedElements = mSharedElements.size();&amp;#10;        ViewGroup decor = getDecor();&amp;#10;        if (decor != null) &amp;#123;&amp;#10;            boolean moveWithParent = moveSharedElementWithParent();&amp;#10;            Matrix tempMatrix = new Matrix();&amp;#10;            for (int i = 0; i &amp;#60; numSharedElements; i++) &amp;#123;&amp;#10;                View view = mSharedElements.get(i);&amp;#10;                tempMatrix.reset();&amp;#10;                mSharedElementParentMatrices.get(i).invert(tempMatrix);&amp;#10;                GhostView.addGhost(view, decor, tempMatrix);&amp;#10;                ViewGroup parent = (ViewGroup) view.getParent();&amp;#10;                if (moveWithParent &amp;#38;&amp;#38; !isInTransitionGroup(parent, decor)) &amp;#123;&amp;#10;                    GhostViewListeners listener = new GhostViewListeners(view, parent, decor);&amp;#10;                    parent.getViewTreeObserver().addOnPreDrawListener(listener);&amp;#10;                    mGhostViewListeners.add(listener);&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;onTakeSharedElements. 开始Transition动画。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void onTakeSharedElements() &amp;#123;&amp;#10;        if (!mIsReadyForTransition || mSharedElementsBundle == null) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        final Bundle sharedElementState = mSharedElementsBundle;&amp;#10;        mSharedElementsBundle = null;&amp;#10;        OnSharedElementsReadyListener listener = new OnSharedElementsReadyListener() &amp;#123;&amp;#10;            @Override&amp;#10;            public void onSharedElementsReady() &amp;#123;&amp;#10;                final View decorView = getDecor();&amp;#10;                if (decorView != null) &amp;#123;&amp;#10;                    decorView.getViewTreeObserver()&amp;#10;                            .addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &amp;#123;&amp;#10;                                @Override&amp;#10;                                public boolean onPreDraw() &amp;#123;&amp;#10;                                    decorView.getViewTreeObserver().removeOnPreDrawListener(this);&amp;#10;                                    startTransition(new Runnable() &amp;#123;&amp;#10;                                        @Override&amp;#10;                                        public void run() &amp;#123;&amp;#10;                                            startSharedElementTransition(sharedElementState);&amp;#10;                                        &amp;#125;&amp;#10;                                    &amp;#125;);&amp;#10;                                    return false;&amp;#10;                                &amp;#125;&amp;#10;                            &amp;#125;);&amp;#10;                    decorView.invalidate();&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;;&amp;#10;        if (mListener == null) &amp;#123;&amp;#10;            listener.onSharedElementsReady();&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            mListener.onSharedElementsArrived(mSharedElementNames, mSharedElements, listener);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开始执行动画&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void startSharedElementTransition(Bundle sharedElementState) &amp;#123;&amp;#10;        ViewGroup decorView = getDecor();&amp;#10;        if (decorView == null) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        // Remove rejected shared elements&amp;#10;        ArrayList&amp;#60;String&amp;#62; rejectedNames = new ArrayList&amp;#60;String&amp;#62;(mAllSharedElementNames);&amp;#10;        rejectedNames.removeAll(mSharedElementNames);&amp;#10;        ArrayList&amp;#60;View&amp;#62; rejectedSnapshots = createSnapshots(sharedElementState, rejectedNames);&amp;#10;        if (mListener != null) &amp;#123;&amp;#10;            mListener.onRejectSharedElements(rejectedSnapshots);&amp;#10;        &amp;#125;&amp;#10;        removeNullViews(rejectedSnapshots);&amp;#10;        startRejectedAnimations(rejectedSnapshots);&amp;#10;&amp;#10;        // Now start shared element transition&amp;#10;        ArrayList&amp;#60;View&amp;#62; sharedElementSnapshots = createSnapshots(sharedElementState,&amp;#10;                mSharedElementNames);&amp;#10;        showViews(mSharedElements, true);&amp;#10;        scheduleSetSharedElementEnd(sharedElementSnapshots);&amp;#10;        ArrayList&amp;#60;SharedElementOriginalState&amp;#62; originalImageViewState =&amp;#10;                setSharedElementState(sharedElementState, sharedElementSnapshots);&amp;#10;        requestLayoutForSharedElements();&amp;#10;&amp;#10;        boolean startEnterTransition = allowOverlappingTransitions() &amp;#38;&amp;#38; !mIsReturning;&amp;#10;        boolean startSharedElementTransition = true;&amp;#10;        setGhostVisibility(View.INVISIBLE);&amp;#10;        scheduleGhostVisibilityChange(View.INVISIBLE);&amp;#10;        pauseInput();&amp;#10;        Transition transition = beginTransition(decorView, startEnterTransition,&amp;#10;                startSharedElementTransition);&amp;#10;        scheduleGhostVisibilityChange(View.VISIBLE);&amp;#10;        setGhostVisibility(View.VISIBLE);&amp;#10;&amp;#10;        if (startEnterTransition) &amp;#123;&amp;#10;            startEnterTransition(transition);&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        setOriginalSharedElementState(mSharedElements, originalImageViewState);&amp;#10;&amp;#10;        if (mResultReceiver != null) &amp;#123;&amp;#10;            // We can&amp;#39;t trust that the view will disappear on the same frame that the shared&amp;#10;            // element appears here. Assure that we get at least 2 frames for double-buffering.&amp;#10;            decorView.postOnAnimation(new Runnable() &amp;#123;&amp;#10;                int mAnimations;&amp;#10;&amp;#10;                @Override&amp;#10;                public void run() &amp;#123;&amp;#10;                    if (mAnimations++ &amp;#60; MIN_ANIMATION_FRAMES) &amp;#123;&amp;#10;                        View decorView = getDecor();&amp;#10;                        if (decorView != null) &amp;#123;&amp;#10;                            decorView.postOnAnimation(this);&amp;#10;                        &amp;#125;&amp;#10;                    &amp;#125; else if (mResultReceiver != null) &amp;#123;&amp;#10;                        mResultReceiver.send(MSG_HIDE_SHARED_ELEMENTS, null);&amp;#10;                        mResultReceiver = null; // all done sending messages.&amp;#10;                    &amp;#125;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自Android L系统发布后，Activity相关的动画API增加了好多，包括Explode, Slide等，这些动画都是在Transition框架之上运行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Make基础</title>
    <link href="http://gonggaofeng.me/2016/03/29/make%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://gonggaofeng.me/2016/03/29/make学习记录/</id>
    <published>2016-03-28T17:00:23.000Z</published>
    <updated>2016-03-28T17:05:35.000Z</updated>
    
    <content type="html">&lt;p&gt;Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和 professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。&lt;/p&gt;
&lt;p&gt;因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;
&lt;p&gt;makefile带来的好处就是–”自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。&lt;/p&gt;
&lt;p&gt;现在讲述如何写 makefile的文章比较少，这是我想写这篇文章的原因。当然，不同厂商的make各不相同，也有不同的语法，但其本质都是在”文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。&lt;/p&gt;
&lt;p&gt;在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。&lt;/p&gt;
&lt;h3 id=&quot;关于程序的编译和链接&quot;&gt;&lt;a href=&quot;#关于程序的编译和链接&quot; class=&quot;headerlink&quot; title=&quot;关于程序的编译和链接&quot;&gt;&lt;/a&gt;关于程序的编译和链接&lt;/h3&gt;&lt;p&gt;在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。&lt;/p&gt;
&lt;p&gt;编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。&lt;/p&gt;
&lt;p&gt;链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫”库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。&lt;/p&gt;
&lt;p&gt;总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.&lt;/p&gt;
&lt;p&gt;好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。&lt;/p&gt;
&lt;h3 id=&quot;Makefile介绍&quot;&gt;&lt;a href=&quot;#Makefile介绍&quot; class=&quot;headerlink&quot; title=&quot;Makefile介绍&quot;&gt;&lt;/a&gt;Makefile介绍&lt;/h3&gt;&lt;p&gt;make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。&lt;/p&gt;
&lt;p&gt;首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感性认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：&lt;/p&gt;
&lt;p&gt;1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。&lt;/p&gt;
&lt;p&gt;2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。&lt;/p&gt;
&lt;p&gt;3）如果这个工程的头文件被改变了，那么我们需要编译引用了这个头文件的所有C文件，并链接目标程序。&lt;/p&gt;
&lt;p&gt;只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。&lt;/p&gt;
&lt;h4 id=&quot;一、Makefile的规则&quot;&gt;&lt;a href=&quot;#一、Makefile的规则&quot; class=&quot;headerlink&quot; title=&quot;一、Makefile的规则&quot;&gt;&lt;/a&gt;一、Makefile的规则&lt;/h4&gt;&lt;p&gt;在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;target ... : prerequisites ...&amp;#10;&amp;#10;&amp;#9;command&amp;#10;&amp;#10;...&amp;#10;&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的”伪目标”章节中会有叙述。&lt;/p&gt;
&lt;p&gt;prerequisites就是，要生成那个target所需要的文件或是目标。&lt;/p&gt;
&lt;p&gt;command也就是make需要执行的命令。（任意的Shell命令）&lt;/p&gt;
&lt;p&gt;这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是 Makefile的规则。也就是Makefile中最核心的内容。&lt;/p&gt;
&lt;p&gt;说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）&lt;/p&gt;
&lt;h4 id=&quot;二、一个示例&quot;&gt;&lt;a href=&quot;#二、一个示例&quot; class=&quot;headerlink&quot; title=&quot;二、一个示例&quot;&gt;&lt;/a&gt;二、一个示例&lt;/h4&gt;&lt;p&gt;正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o&amp;#10;&amp;#10;&amp;#9;cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o&amp;#10;&amp;#10;main.o : main.c defs.h&amp;#10;&amp;#10;&amp;#9;cc -c main.c&amp;#10;&amp;#10;kbd.o : kbd.c defs.h command.h&amp;#10;&amp;#10;&amp;#9;cc -c kbd.c&amp;#10;&amp;#10;command.o : command.c defs.h command.h&amp;#10;&amp;#10;&amp;#9;cc -c command.c&amp;#10;&amp;#10;display.o : display.c defs.h buffer.h&amp;#10;&amp;#10;&amp;#9;cc -c display.c&amp;#10;&amp;#10;insert.o : insert.c defs.h buffer.h&amp;#10;&amp;#10;&amp;#9;cc -c insert.c&amp;#10;&amp;#10;search.o : search.c defs.h buffer.h&amp;#10;&amp;#10;&amp;#9;cc -c search.c&amp;#10;&amp;#10;files.o : files.c defs.h buffer.h command.h&amp;#10;&amp;#10;&amp;#9;cc -c files.c&amp;#10;&amp;#10;utils.o : utils.c defs.h&amp;#10;&amp;#10;&amp;#9;cc -c utils.c&amp;#10;&amp;#10;clean :&amp;#10;&amp;#10;&amp;#9;rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;换行可使用反斜杠（\）。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为”Makefile”或”makefile”的文件中，然后在该目录下直接输入命令”make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下”make clean”就可以了。&lt;/p&gt;
&lt;p&gt;在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。&lt;/p&gt;
&lt;p&gt;在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。&lt;/p&gt;
&lt;p&gt;这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。&lt;/p&gt;
&lt;h4 id=&quot;三、make是如何工作的&quot;&gt;&lt;a href=&quot;#三、make是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;三、make是如何工作的&quot;&gt;&lt;/a&gt;三、make是如何工作的&lt;/h4&gt;&lt;p&gt;在默认的方式下，也就是我们只输入make命令。那么：&lt;/p&gt;
&lt;p&gt;1、make会在当前目录下找名字叫”Makefile”或”makefile”的文件。&lt;/p&gt;
&lt;p&gt;2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到”edit”这个文件，并把这个文件作为最终的目标文件。&lt;/p&gt;
&lt;p&gt;3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。&lt;/p&gt;
&lt;p&gt;4、如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）&lt;/p&gt;
&lt;p&gt;5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。&lt;/p&gt;
&lt;p&gt;这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。&lt;/p&gt;
&lt;p&gt;通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令–”make clean”，以此来清除所有的目标文件，以便重编译。&lt;/p&gt;
&lt;p&gt;于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。&lt;/p&gt;
&lt;p&gt;而如果我们改变了”command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。&lt;/p&gt;
&lt;h4 id=&quot;四、makefile中使用变量&quot;&gt;&lt;a href=&quot;#四、makefile中使用变量&quot; class=&quot;headerlink&quot; title=&quot;四、makefile中使用变量&quot;&gt;&lt;/a&gt;四、makefile中使用变量&lt;/h4&gt;&lt;p&gt;在上面的例子中，先让我们看看edit的规则：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o&amp;#10;&amp;#10;&amp;#9;cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在 clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成 C语言中的宏可能会更好。&lt;/p&gt;
&lt;p&gt;比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;于是，我们就可以很方便地在我们的makefile中以”$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o&amp;#10;&amp;#10;edit : $(objects)&amp;#10;&amp;#10;&amp;#9;cc -o edit $(objects)&amp;#10;&amp;#10;main.o : main.c defs.h&amp;#10;&amp;#10;&amp;#9;cc -c main.c&amp;#10;&amp;#10;kbd.o : kbd.c defs.h command.h&amp;#10;&amp;#10;&amp;#9;cc -c kbd.c&amp;#10;&amp;#10;command.o : command.c defs.h command.h&amp;#10;&amp;#10;&amp;#9;cc -c command.c&amp;#10;&amp;#10;display.o : display.c defs.h buffer.h&amp;#10;&amp;#10;&amp;#9;cc -c display.c&amp;#10;&amp;#10;insert.o : insert.c defs.h buffer.h&amp;#10;&amp;#10;&amp;#9;cc -c insert.c&amp;#10;&amp;#10;search.o : search.c defs.h buffer.h&amp;#10;&amp;#10;&amp;#9;cc -c search.c&amp;#10;&amp;#10;files.o : files.c defs.h buffer.h command.h&amp;#10;&amp;#10;&amp;#9;cc -c files.c&amp;#10;&amp;#10;utils.o : utils.c defs.h&amp;#10;&amp;#10;&amp;#9;cc -c utils.c&amp;#10;&amp;#10;clean :&amp;#10;&amp;#10;&amp;#9;rm edit $(objects)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。&lt;/p&gt;
&lt;p&gt;关于变量更多的话题，我会在后续给你一一道来。&lt;/p&gt;
&lt;h4 id=&quot;五、让make自动推导&quot;&gt;&lt;a href=&quot;#五、让make自动推导&quot; class=&quot;headerlink&quot; title=&quot;五、让make自动推导&quot;&gt;&lt;/a&gt;五、让make自动推导&lt;/h4&gt;&lt;p&gt;GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。&lt;/p&gt;
&lt;p&gt;只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o&amp;#10;&amp;#10;edit : $(objects)&amp;#10;&amp;#10;&amp;#9;cc -o edit $(objects)&amp;#10;&amp;#10;main.o : defs.h&amp;#10;&amp;#10;kbd.o : defs.h command.h&amp;#10;&amp;#10;command.o : defs.h command.h&amp;#10;&amp;#10;display.o : defs.h buffer.h&amp;#10;&amp;#10;insert.o : defs.h buffer.h&amp;#10;&amp;#10;search.o : defs.h buffer.h&amp;#10;&amp;#10;files.o : defs.h buffer.h command.h&amp;#10;&amp;#10;utils.o : defs.h&amp;#10;&amp;#10;.PHONY : clean&amp;#10;&amp;#10;clean :&amp;#10;&amp;#10;&amp;#9;rm edit $(objects)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法，也就是make的”隐晦规则”。上面文件内容中，”.PHONY”表示，clean是个伪目标文件。&lt;/p&gt;
&lt;p&gt;关于更为详细的”隐晦规则”和”伪目标文件”，我会在后续给你一一道来。&lt;/p&gt;
&lt;h4 id=&quot;六、另类风格的makefile&quot;&gt;&lt;a href=&quot;#六、另类风格的makefile&quot; class=&quot;headerlink&quot; title=&quot;六、另类风格的makefile&quot;&gt;&lt;/a&gt;六、另类风格的makefile&lt;/h4&gt;&lt;p&gt;即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o&amp;#10;&amp;#10;edit : $(objects)&amp;#10;&amp;#10;&amp;#9;cc -o edit $(objects)&amp;#10;&amp;#10;$(objects) : defs.h&amp;#10;&amp;#10;kbd.o command.o files.o : command.h&amp;#10;&amp;#10;display.o insert.o search.o files.o : buffer.h&amp;#10;&amp;#10;.PHONY : clean&amp;#10;&amp;#10;clean :&amp;#10;&amp;#10;&amp;#9;rm edit $(objects)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。&lt;/p&gt;
&lt;h4 id=&quot;七、清空目标文件的规则&quot;&gt;&lt;a href=&quot;#七、清空目标文件的规则&quot; class=&quot;headerlink&quot; title=&quot;七、清空目标文件的规则&quot;&gt;&lt;/a&gt;七、清空目标文件的规则&lt;/h4&gt;&lt;p&gt;每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个”修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;clean:&amp;#10;&amp;#10;&amp;#9;rm edit $(objects)&amp;#10;&amp;#10;&amp;#26356;&amp;#20026;&amp;#31283;&amp;#20581;&amp;#30340;&amp;#20570;&amp;#27861;&amp;#26159;&amp;#65306;&amp;#10;&amp;#10;.PHONY : clean&amp;#10;&amp;#10;clean :&amp;#10;&amp;#10;&amp;#9;-rm edit $(objects)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前面说过，.PHONY意思表示clean是一个”伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是–”clean从来都是放在文件的最后”。&lt;/p&gt;
&lt;p&gt;上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。&lt;/p&gt;
&lt;h3 id=&quot;Makefile总述&quot;&gt;&lt;a href=&quot;#Makefile总述&quot; class=&quot;headerlink&quot; title=&quot;Makefile总述&quot;&gt;&lt;/a&gt;Makefile总述&lt;/h3&gt;&lt;h4 id=&quot;一、Makefile里有什么&quot;&gt;&lt;a href=&quot;#一、Makefile里有什么&quot; class=&quot;headerlink&quot; title=&quot;一、Makefile里有什么&quot;&gt;&lt;/a&gt;一、Makefile里有什么&lt;/h4&gt;&lt;p&gt;Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。&lt;/p&gt;
&lt;p&gt;1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/p&gt;
&lt;p&gt;2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。&lt;/p&gt;
&lt;p&gt;3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/p&gt;
&lt;p&gt;4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/p&gt;
&lt;p&gt;5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用”#”字符，这个就像C/C++中的”//“一样。如果你要在你的Makefile中使用”#”字符，可以用反斜框进行转义，如：”#“。&lt;/p&gt;
&lt;p&gt;最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。&lt;/p&gt;
&lt;h4 id=&quot;二、Makefile的文件名&quot;&gt;&lt;a href=&quot;#二、Makefile的文件名&quot; class=&quot;headerlink&quot; title=&quot;二、Makefile的文件名&quot;&gt;&lt;/a&gt;二、Makefile的文件名&lt;/h4&gt;&lt;p&gt;默认的情况下，make命令会在当前目录下按顺序找寻文件名为”GNUmakefile”、”makefile”、”Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用”Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的”makefile”文件名敏感，但是基本上来说，大多数的make都支持”makefile”和”Makefile”这两种默认文件名。&lt;/p&gt;
&lt;p&gt;当然，你可以使用别的文件名来书写Makefile，比如：”Make.Linux”，”Make.Solaris”，”Make.AIX”等，如果要指定特定的Makefile，你可以使用make的”- f”和”–file”参数，如：make -f Make.Linux或make –file Make.AIX。&lt;/p&gt;
&lt;h4 id=&quot;三、引用其它的Makefile&quot;&gt;&lt;a href=&quot;#三、引用其它的Makefile&quot; class=&quot;headerlink&quot; title=&quot;三、引用其它的Makefile&quot;&gt;&lt;/a&gt;三、引用其它的Makefile&lt;/h4&gt;&lt;p&gt;在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &amp;#60;filename&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）&lt;/p&gt;
&lt;p&gt;在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&amp;lt;filename&amp;gt;可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和 f.mk，那么，下面的语句：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include foo.make *.mk $(bar)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include foo.make a.mk b.mk c.mk e.mk f.mk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;make 命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：&lt;/p&gt;
&lt;p&gt;1、如果make执行时，有”-I”或”–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。&lt;/p&gt;
&lt;p&gt;2、如果目录&amp;lt;prefix&amp;gt;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。&lt;/p&gt;
&lt;p&gt;如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在 include前加一个减号”-“。如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-include &amp;#60;filename&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。&lt;/p&gt;
&lt;h4 id=&quot;四、环境变量-MAKEFILES&quot;&gt;&lt;a href=&quot;#四、环境变量-MAKEFILES&quot; class=&quot;headerlink&quot; title=&quot;四、环境变量 MAKEFILES&quot;&gt;&lt;/a&gt;四、环境变量 MAKEFILES&lt;/h4&gt;&lt;p&gt;如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的”目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。&lt;/p&gt;
&lt;p&gt;但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的 Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。&lt;/p&gt;
&lt;h4 id=&quot;五、make的工作方式&quot;&gt;&lt;a href=&quot;#五、make的工作方式&quot; class=&quot;headerlink&quot; title=&quot;五、make的工作方式&quot;&gt;&lt;/a&gt;五、make的工作方式&lt;/h4&gt;&lt;p&gt;GNU的make工作时的执行步骤入下：（想来其它的make也是类似）&lt;/p&gt;
&lt;p&gt;1、读入所有的Makefile。&lt;/p&gt;
&lt;p&gt;2、读入被include的其它Makefile。&lt;/p&gt;
&lt;p&gt;3、初始化文件中的变量。&lt;/p&gt;
&lt;p&gt;4、推导隐晦规则，并分析所有规则。&lt;/p&gt;
&lt;p&gt;5、为所有的目标文件创建依赖关系链。&lt;/p&gt;
&lt;p&gt;6、根据依赖关系，决定哪些目标要重新生成。&lt;/p&gt;
&lt;p&gt;7、执行生成命令。&lt;/p&gt;
&lt;p&gt;1-5 步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。&lt;/p&gt;
&lt;p&gt;当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。&lt;/p&gt;
&lt;h3 id=&quot;书写规则&quot;&gt;&lt;a href=&quot;#书写规则&quot; class=&quot;headerlink&quot; title=&quot;书写规则&quot;&gt;&lt;/a&gt;书写规则&lt;/h3&gt;&lt;p&gt;规则包含两个部分，一个是依赖关系，一个是生成目标的方法。&lt;/p&gt;
&lt;p&gt;在 Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。&lt;/p&gt;
&lt;p&gt;好了，还是让我们来看一看如何书写规则。&lt;/p&gt;
&lt;h4 id=&quot;一、规则举例&quot;&gt;&lt;a href=&quot;#一、规则举例&quot; class=&quot;headerlink&quot; title=&quot;一、规则举例&quot;&gt;&lt;/a&gt;一、规则举例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo.o : foo.c defs.h # foo&amp;#27169;&amp;#22359;&amp;#10;&amp;#10;&amp;#9;cc -c -g foo.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令”cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：&lt;/p&gt;
&lt;p&gt;1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。&lt;/p&gt;
&lt;p&gt;2、如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）&lt;/p&gt;
&lt;h4 id=&quot;二、规则的语法&quot;&gt;&lt;a href=&quot;#二、规则的语法&quot; class=&quot;headerlink&quot; title=&quot;二、规则的语法&quot;&gt;&lt;/a&gt;二、规则的语法&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;targets : prerequisites&amp;#10;&amp;#10;&amp;#9;command&amp;#10;&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;targets : prerequisites ; command&amp;#10;&amp;#10;&amp;#9;command&amp;#10;&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。&lt;/p&gt;
&lt;p&gt;command是命令行，如果其不与”target吐舌rerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是”过时的”，被认为是需要重生成的。这个在前面已经讲过了。&lt;/p&gt;
&lt;p&gt;如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。&lt;/p&gt;
&lt;p&gt;一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。&lt;/p&gt;
&lt;h4 id=&quot;三、在规则中使用通配符&quot;&gt;&lt;a href=&quot;#三、在规则中使用通配符&quot; class=&quot;headerlink&quot; title=&quot;三、在规则中使用通配符&quot;&gt;&lt;/a&gt;三、在规则中使用通配符&lt;/h4&gt;&lt;p&gt;如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：”*”，”?”和”[…]”。这是和Unix的B-Shell是相同的。&lt;/p&gt;
&lt;p&gt;波浪号（”~”）字符在文件名中也有比较特殊的用途。如果是”~/test”，这就表示当前用户的$HOME目录下的test目录。而”~hchen /test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量”HOME”而定。&lt;/p&gt;
&lt;p&gt;通配符代替了你一系列的文件，如”&lt;em&gt;.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：”\&lt;/em&gt;“，那么可以用转义字符”\“，如”\*“来表示真实的”*“字符，而不是任意长度的字符串。&lt;/p&gt;
&lt;p&gt;好吧，还是先来看几个例子吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;clean:&amp;#10;&amp;#10;&amp;#9;rm -f *.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print: *.c&amp;#10;&amp;#10;lpr -p $?&amp;#10;&amp;#10;touch print&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的”$?”是一个自动化变量，我会在后面给你讲述。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = *.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是”*.o”。Makefile中的变量其实就是 C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects := $(wildcard *.o)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这种用法由关键字”wildcard”指出，关于Makefile的关键字，我们将在后面讨论。&lt;/p&gt;
&lt;h4 id=&quot;四、文件搜寻&quot;&gt;&lt;a href=&quot;#四、文件搜寻&quot; class=&quot;headerlink&quot; title=&quot;四、文件搜寻&quot;&gt;&lt;/a&gt;四、文件搜寻&lt;/h4&gt;&lt;p&gt;在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。&lt;/p&gt;
&lt;p&gt;Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;VPATH = src:../headers&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的的定义指定两个目录，”src”和”../headers”，make会按照这个顺序进行搜索。目录由”冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）&lt;/p&gt;
&lt;p&gt;另一个设置文件搜索路径的方法是使用make的”vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个 VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：&lt;/p&gt;
&lt;p&gt;1、vpath &amp;lt;pattern&amp;gt; &amp;lt;directories&amp;gt;为符合模式&amp;lt;pattern&amp;gt;的文件指定搜索目录&amp;lt;directories&amp;gt;。&lt;/p&gt;
&lt;p&gt;2、vpath &amp;lt;pattern&amp;gt;清除符合模式&amp;lt;pattern&amp;gt;的文件的搜索目录。&lt;/p&gt;
&lt;p&gt;3、vpath清除所有已被设置好了的文件搜索目录。&lt;/p&gt;
&lt;p&gt;vapth 使用方法中的&amp;lt;pattern&amp;gt;需要包含”%”字符。”%”的意思是匹配零或若干字符，例如，”%.h”表示所有以”.h”结尾的文件。&amp;lt;pattern&amp;gt;指定了要搜索的文件集，而&amp;lt;directories&amp;gt;则指定了&amp;lt;pattern&amp;gt;的文件集的搜索的目录。例如：&lt;/p&gt;
&lt;p&gt;vpath %.h ../headers&lt;/p&gt;
&lt;p&gt;该语句表示，要求make在”../headers”目录下搜索所有以”.h”结尾的文件。（如果某文件在当前目录没有找到的话）我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&amp;lt;pattern&amp;gt;，或是被重复了的&amp;lt;pattern&amp;gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vpath %.c foo&amp;#10;&amp;#10;vpath % blish&amp;#10;&amp;#10;vpath %.c bar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其表示”.c”结尾的文件，先在”foo”目录，然后是”blish”，最后是”bar”目录。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vpath %.c foo:bar&amp;#10;&amp;#10;vpath % blish&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而上面的语句则表示”.c”结尾的文件，先在”foo”目录，然后是”bar”目录，最后才是”blish”目录。&lt;/p&gt;
&lt;h4 id=&quot;五、伪目标&quot;&gt;&lt;a href=&quot;#五、伪目标&quot; class=&quot;headerlink&quot; title=&quot;五、伪目标&quot;&gt;&lt;/a&gt;五、伪目标&lt;/h4&gt;&lt;p&gt;最早先的一个例子中，我们提到过一个”clean”的目标，这是一个”伪目标”：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;clean:&amp;#10;&amp;#10;&amp;#9;rm *.o temp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正像我们前面例子中的”clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的”目标”以备完整地重编译而用。（以”make clean”来使用该目标）因为，我们并不生成”clean”这个文件。”伪目标”并不是一个文件，只是一个标签，由于”伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个”目标”才能让其生效。当然，”伪目标”的取名不能和文件名重名，不然其就失去了”伪目标”的意义了。&lt;/p&gt;
&lt;p&gt;当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记”.PHONY”来显示地指明一个目标是”伪目标”，向make说明，不管是否有这个文件，这个目标就是”伪目标”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.PHONY : clean&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只要有这个声明，不管是否有”clean”文件，要运行”clean”这个目标，只有”make clean”这样。于是整个过程可以这样写：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.PHONY: clean&amp;#10;&amp;#10;clean:&amp;#10;&amp;#10;&amp;#9;rm *.o temp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为”默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用”伪目标”这个特性：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;all : prog1 prog2 prog3&amp;#10;&amp;#10;.PHONY : all&amp;#10;&amp;#10;prog1 : prog1.o utils.o&amp;#10;&amp;#10;&amp;#9;cc -o prog1 prog1.o utils.o&amp;#10;&amp;#10;prog2 : prog2.o&amp;#10;&amp;#10;&amp;#9;cc -o prog2 prog2.o&amp;#10;&amp;#10;prog3 : prog3.o sort.o utils.o&amp;#10;&amp;#10;&amp;#9;cc -o prog3 prog3.o sort.o utils.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个”all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如”all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 “.PHONY : all”声明了”all”这个目标为”伪目标”。&lt;/p&gt;
&lt;p&gt;随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.PHONY: cleanall cleanobj cleandiff&amp;#10;&amp;#10;cleanall : cleanobj cleandiff&amp;#10;&amp;#10;&amp;#9;rm program&amp;#10;&amp;#10;cleanobj :&amp;#10;&amp;#10;&amp;#9;rm *.o&amp;#10;&amp;#10;cleandiff :&amp;#10;&amp;#10;&amp;#9;rm *.diff&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;“make clean”将清除所有要被清除的文件。”cleanobj”和”cleandiff”这两个伪目标有点像”子程序”的意思。我们可以输入”make cleanall”和”make cleanobj”和”make cleandiff”命令来达到清除不同种类文件的目的。&lt;/p&gt;
&lt;h4 id=&quot;六、多目标&quot;&gt;&lt;a href=&quot;#六、多目标&quot; class=&quot;headerlink&quot; title=&quot;六、多目标&quot;&gt;&lt;/a&gt;六、多目标&lt;/h4&gt;&lt;p&gt;Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量”$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bigoutput littleoutput : text.g&amp;#10;&amp;#10;generate text.g -$(subst output,,$@) &amp;#62; $@&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述规则等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bigoutput : text.g&amp;#10;&amp;#10;generate text.g -big &amp;#62; bigoutput&amp;#10;&amp;#10;littleoutput : text.g&amp;#10;&amp;#10;generate text.g -little &amp;#62; littleoutput&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，-$(subst output,,$@)中的”$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，”$@”表示目标的集合，就像一个数组，”$@”依次取出目标，并执于命令。&lt;/p&gt;
&lt;h4 id=&quot;七、静态模式&quot;&gt;&lt;a href=&quot;#七、静态模式&quot; class=&quot;headerlink&quot; title=&quot;七、静态模式&quot;&gt;&lt;/a&gt;七、静态模式&lt;/h4&gt;&lt;p&gt;静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;targets ...&amp;#62;: &amp;#60;target-pattern&amp;#62;: &amp;#60;prereq-patterns ...&amp;#62;&amp;#10;&amp;#10;&amp;#60;tab&amp;#62;&amp;#60;commands&amp;#62;&amp;#10;&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;/p&gt;
&lt;p&gt;target-parrtern是指明了targets的模式，也就是的目标集模式。&lt;/p&gt;
&lt;p&gt;prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。&lt;/p&gt;
&lt;p&gt;这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&amp;lt;target-parrtern&amp;gt;定义成”%.o”，意思是我们的&amp;lt;target&amp;gt;集合中都是以”.o”结尾的，而如果我们的&amp;lt;prereq-parrterns&amp;gt;定义成”%.c”，意思是对&amp;lt;target-parrtern&amp;gt;所形成的目标集进行二次定义，其计算方法是，取&amp;lt;target-parrtern&amp;gt;模式中的”%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。&lt;/p&gt;
&lt;p&gt;所以，我们的”目标模式”或是”依赖模式”中都应该有”%”这个字符，如果你的文件名中有”%”那么你可以使用反斜杠”\”进行转义，来标明真实的”%”字符。&lt;/p&gt;
&lt;p&gt;看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = foo.o bar.o&amp;#10;&amp;#10;all: $(objects)&amp;#10;&amp;#10;$(objects): %.o: %.c&amp;#10;&amp;#10;&amp;#9;$(CC) -c $(CFLAGS) $&amp;#60; -o $@&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的例子中，指明了我们的目标从$object中获取，”%.o”表明要所有以”.o”结尾的目标，也就是”foo.o bar.o”，也就是变量$object集合的模式，而依赖模式”%.c”则取模式”%.o”的”%”，也就是”foo bar”，并为其加下”.c”的后缀，于是，我们的依赖目标就是”foo.c bar.c”。而命令中的”$&amp;lt;”和”$@”则是自动化变量，”$&amp;lt;”表示所有的依赖目标集（也就是”foo.c bar.c”），”$@”表示目标集（也就是”foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo.o : foo.c&amp;#10;&amp;#10;&amp;#9;$(CC) -c $(CFLAGS) foo.c -o foo.o&amp;#10;&amp;#10;bar.o : bar.c&amp;#10;&amp;#10;&amp;#9;$(CC) -c $(CFLAGS) bar.c -o bar.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;试想，如果我们的”%.o”有几百个，那种我们只要用这种很简单的”静态模式规则”就可以写完一堆规则，实在是太有效率了。”静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;files = foo.elc bar.o lose.o&amp;#10;&amp;#10;$(filter %.o,$(files)): %.o: %.c&amp;#10;&amp;#10;&amp;#9;$(CC) -c $(CFLAGS) $&amp;#60; -o $@&amp;#10;&amp;#10;$(filter %.elc,$(files)): %.elc: %.el&amp;#10;&amp;#10;&amp;#9;emacs -f batch-byte-compile $&amp;#60;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;$(filter %.o,$(files))表示调用Makefile的filter函数，过滤”$filter”集，只要其中模式为”%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。&lt;/p&gt;
&lt;h4 id=&quot;八、自动生成依赖性&quot;&gt;&lt;a href=&quot;#八、自动生成依赖性&quot; class=&quot;headerlink&quot; title=&quot;八、自动生成依赖性&quot;&gt;&lt;/a&gt;八、自动生成依赖性&lt;/h4&gt;&lt;p&gt;在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句”#include “defs.h””，那么我们的依赖关系应该是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.o : main.c defs.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个”-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cc -M main.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其输出是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.o : main.c defs.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用”-MM”参数，不然，”-M”参数会把一些标准库的头文件也包含进来。&lt;/p&gt;
&lt;p&gt;gcc -M main.c的输出是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \&amp;#10;&amp;#10;/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \&amp;#10;&amp;#10;/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \&amp;#10;&amp;#10;/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \&amp;#10;&amp;#10;/usr/include/bits/sched.h /usr/include/libio.h \&amp;#10;&amp;#10;/usr/include/_G_config.h /usr/include/wchar.h \&amp;#10;&amp;#10;/usr/include/bits/wchar.h /usr/include/gconv.h \&amp;#10;&amp;#10;/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \&amp;#10;&amp;#10;/usr/include/bits/stdio_lim.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;gcc -MM main.c的输出则是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.o: main.c defs.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile 自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个”name.c”的文件都生成一个”name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。&lt;/p&gt;
&lt;p&gt;于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。&lt;/p&gt;
&lt;p&gt;这里，我们给出了一个模式规则来产生[.d]文件：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;%.d: %.c&amp;#10;&amp;#10;@set -e; rm -f $@; \&amp;#10;&amp;#10;$(CC) -M $(CPPFLAGS) $&amp;#60; &amp;#62; $@.$$$$; \&amp;#10;&amp;#10;sed &amp;#39;s,\($*\)\.o[ :]*,\1.o $@ : ,g&amp;#39; &amp;#60; $@.$$$$ &amp;#62; $@; \&amp;#10;&amp;#10;rm -f [$@.$$$$](mailto:$@.$$$$)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个规则的意思是，所有的[.d]文件依赖于[.c]文件，”rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件”$&amp;lt;”，也就是[.c]文件生成依赖文件，”$@”表示模式 “%.d”文件，如果有一个C文件是name.c，那么”%”就是”name”，”$$$$”意为一个随机编号，第二行生成的文件有可能是 “name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。&lt;/p&gt;
&lt;p&gt;总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.o : main.c defs.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;转成：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.o main.d : main.c defs.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 [.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用 Makefile的”include”命令，来引入别的Makefile文件（前面讲过），例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sources = foo.c bar.c&amp;#10;&amp;#10;include $(sources:.c=.d)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述语句中的”$(sources:.c=.d)”中的”.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成 [.d]，关于这个”替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。&lt;/p&gt;
&lt;h3 id=&quot;书写命令&quot;&gt;&lt;a href=&quot;#书写命令&quot; class=&quot;headerlink&quot; title=&quot;书写命令&quot;&gt;&lt;/a&gt;书写命令&lt;/h3&gt;&lt;p&gt;每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。&lt;/p&gt;
&lt;p&gt;我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被”/bin/sh”–UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，”#”是注释符，很像C/C++中的”//“，其后的本行字符都被注释。&lt;/p&gt;
&lt;h4 id=&quot;一、显示命令&quot;&gt;&lt;a href=&quot;#一、显示命令&quot; class=&quot;headerlink&quot; title=&quot;一、显示命令&quot;&gt;&lt;/a&gt;一、显示命令&lt;/h4&gt;&lt;p&gt;通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用”@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：&lt;/p&gt;
&lt;p&gt;@echo 正在编译XXX模块……&lt;/p&gt;
&lt;p&gt;当make执行时，会输出”正在编译XXX模块……”字串，但不会输出命令，如果没有”@”，那么，make将输出：&lt;/p&gt;
&lt;p&gt;echo 正在编译XXX模块……&lt;/p&gt;
&lt;p&gt;正在编译XXX模块……&lt;/p&gt;
&lt;p&gt;如果make执行时，带入make参数”-n”或”–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。&lt;/p&gt;
&lt;p&gt;而make参数”-s”或”–slient”则是全面禁止命令的显示。&lt;/p&gt;
&lt;h4 id=&quot;二、命令执行&quot;&gt;&lt;a href=&quot;#二、命令执行&quot; class=&quot;headerlink&quot; title=&quot;二、命令执行&quot;&gt;&lt;/a&gt;二、命令执行&lt;/h4&gt;&lt;p&gt;当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：&lt;/p&gt;
&lt;p&gt;示例一：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;exec:&amp;#10;&amp;#10;&amp;#9;cd /home/hchen&amp;#10;&amp;#10;pwd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例二：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;exec:&amp;#10;&amp;#10;cd /home/hchen; pwd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当我们执行”make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出”/home/hchen”。&lt;/p&gt;
&lt;p&gt;make 一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell–/bin/sh来执行命令。但在MS- DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如”.exe”、”.com”、”.bat”、”.sh”等后缀。&lt;/p&gt;
&lt;h4 id=&quot;三、命令出错&quot;&gt;&lt;a href=&quot;#三、命令出错&quot; class=&quot;headerlink&quot; title=&quot;三、命令出错&quot;&gt;&lt;/a&gt;三、命令出错&lt;/h4&gt;&lt;p&gt;每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;/p&gt;
&lt;p&gt;有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。&lt;/p&gt;
&lt;p&gt;为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号”-“（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;clean:&amp;#10;&amp;#10;-rm -f *.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还有一个全局的办法是，给make加上”-i”或是”–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以”.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。&lt;/p&gt;
&lt;p&gt;还有一个要提一下的make的参数的是”-k”或是”–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。&lt;/p&gt;
&lt;h4 id=&quot;四、嵌套执行make&quot;&gt;&lt;a href=&quot;#四、嵌套执行make&quot; class=&quot;headerlink&quot; title=&quot;四、嵌套执行make&quot;&gt;&lt;/a&gt;四、嵌套执行make&lt;/h4&gt;&lt;p&gt;在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。&lt;/p&gt;
&lt;p&gt;例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;subsystem:&amp;#10;&amp;#10;&amp;#9;cd subdir &amp;#38;&amp;#38; $(MAKE)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;subsystem:&amp;#10;&amp;#10;&amp;#9;$(MAKE) -C subdir&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入”subdir”目录，然后执行make命令。&lt;/p&gt;
&lt;p&gt;我们把这个Makefile叫做”总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了”-e”参数。&lt;/p&gt;
&lt;p&gt;如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export &amp;#60;variable ...&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unexport &amp;#60;variable ...&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;示例一：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export variable = value&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;variable = value&amp;#10;&amp;#10;export variable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export variable := value&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;variable := value&amp;#10;&amp;#10;export variable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例二：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export variable += value&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;variable += value&amp;#10;&amp;#10;export variable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。&lt;/p&gt;
&lt;p&gt;需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行”总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。&lt;/p&gt;
&lt;p&gt;但是make命令中的有几个参数并不往下传递，它们是”-C”,”-f”,”-h””-o”和”-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;subsystem:&amp;#10;&amp;#10;cd subdir &amp;#38;&amp;#38; $(MAKE) MAKEFLAGS=&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有”-t”,”-n”,和”-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。&lt;/p&gt;
&lt;p&gt;还有一个在”嵌套执行”中比较有用的参数，”-w”或是”–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是”/home/hchen/gnu/make”，如果我们使用”make -w”来执行，那么当进入该目录时，我们会看到：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;make: Entering directory `/home/hchen/gnu/make&amp;#39;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而在完成下层make后离开目录时，我们会看到：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;make: Leaving directory `/home/hchen/gnu/make&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你使用”-C”参数来指定make下层Makefile时，”-w”会被自动打开的。如果参数中有”-s”（”–slient”）或是”–no-print-directory”，那么，”-w”总是失效的。&lt;/p&gt;
&lt;h4 id=&quot;五、定义命令包&quot;&gt;&lt;a href=&quot;#五、定义命令包&quot; class=&quot;headerlink&quot; title=&quot;五、定义命令包&quot;&gt;&lt;/a&gt;五、定义命令包&lt;/h4&gt;&lt;p&gt;如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以”define”开始，以”endef”结束，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define run-yacc&amp;#10;&amp;#10;yacc $(firstword $^)&amp;#10;&amp;#10;mv y.tab.c $@&amp;#10;&amp;#10;endef&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里，”run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在”define”和”endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成”y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo.c : foo.y&amp;#10;&amp;#10;&amp;#9;$(run-yacc)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包”run-yacc”中的”$^”就是”foo.y”，”$@”就是”foo.c”（有关这种以 “$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。&lt;/p&gt;
&lt;h3 id=&quot;使用变量&quot;&gt;&lt;a href=&quot;#使用变量&quot; class=&quot;headerlink&quot; title=&quot;使用变量&quot;&gt;&lt;/a&gt;使用变量&lt;/h3&gt;&lt;p&gt;在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在”目标”，”依赖目标”，”命令”或是 Makefile的其它部分中。&lt;/p&gt;
&lt;p&gt;变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有”:”、”#”、”=”或是空字符（空格、回车等）。变量是大小写敏感的，”foo”、”Foo”和”FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。&lt;/p&gt;
&lt;p&gt;有一些变量是很奇怪字串，如”$&amp;lt;”、”$@”等，这些是自动化变量，我会在后面介绍。&lt;/p&gt;
&lt;h4 id=&quot;一、变量的基础&quot;&gt;&lt;a href=&quot;#一、变量的基础&quot; class=&quot;headerlink&quot; title=&quot;一、变量的基础&quot;&gt;&lt;/a&gt;一、变量的基础&lt;/h4&gt;&lt;p&gt;变量在声明时需要给予初值，而在使用时，需要给在变量名前加上”$”符号，但最好用小括号”（）”或是大括号”{}”把变量给包括起来。如果你要使用真实的”$”字符，那么你需要用”$$”来表示。&lt;/p&gt;
&lt;p&gt;变量可以使用在许多地方，如规则中的”目标”、”依赖”、”命令”以及新的变量中。先看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = program.o foo.o utils.o&amp;#10;&amp;#10;program : $(objects)&amp;#10;&amp;#10;&amp;#9;cc -o program $(objects)&amp;#10;&amp;#10;$(objects) : defs.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo = c&amp;#10;&amp;#10;prog.o : prog.$(foo)&amp;#10;&amp;#10;&amp;#9;$(foo)$(foo) -$(foo) prog.$(foo)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;展开后得到：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;prog.o : prog.c&amp;#10;&amp;#10;cc -c prog.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个”替代”的原理。&lt;/p&gt;
&lt;p&gt;另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。&lt;/p&gt;
&lt;h4 id=&quot;二、变量中的变量&quot;&gt;&lt;a href=&quot;#二、变量中的变量&quot; class=&quot;headerlink&quot; title=&quot;二、变量中的变量&quot;&gt;&lt;/a&gt;二、变量中的变量&lt;/h4&gt;&lt;p&gt;在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。&lt;/p&gt;
&lt;p&gt;先看第一种方式，也就是简单的使用”=”号，在”=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo = $(bar)&amp;#10;&amp;#10;bar = $(ugh)&amp;#10;&amp;#10;ugh = Huh?&amp;#10;&amp;#10;all:&amp;#10;&amp;#10;echo $(foo)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们执行”make all”将会打出变量$(foo)的值是”Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是”Huh?”）可见，变量是可以使用后面的变量来定义的。&lt;/p&gt;
&lt;p&gt;这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面&lt;br&gt;来定义，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CFLAGS = $(include_dirs) &amp;#8211;O&amp;#10;&amp;#10;include_dirs = -Ifoo &amp;#8211;Ibar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当”CFLAGS”在命令中被展开时，会是”-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CFLAGS = $(CFLAGS) &amp;#8211;O&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A = $(B)&amp;#10;&amp;#10;B = $(A)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数”wildcard”和”shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。&lt;/p&gt;
&lt;p&gt;为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是”:=”操作符，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x := foo&amp;#10;&amp;#10;y := $(x) bar&amp;#10;&amp;#10;x := later&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;y := foo bar&amp;#10;&amp;#10;x := later&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;y := $(x) bar&amp;#10;&amp;#10;x := foo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么，y的值是”bar”，而不是”foo bar”。&lt;/p&gt;
&lt;p&gt;上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量”MAKELEVEL”的使用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifeq (0,$&amp;#123;MAKELEVEL&amp;#125;)&amp;#10;&amp;#10;cur-dir := $(shell pwd)&amp;#10;&amp;#10;whoami := $(shell whoami)&amp;#10;&amp;#10;host-type := $(shell arch)&amp;#10;&amp;#10;MAKE := $&amp;#123;MAKE&amp;#125; host-type=$&amp;#123;host-type&amp;#125; whoami=$&amp;#123;whoami&amp;#125;&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;关于条件表达式和函数，我们在后面再说，对于系统变量”MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的”嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。&lt;/p&gt;
&lt;p&gt;下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nullstring :=&amp;#10;&amp;#10;space := $(nullstring) # end of the line&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用”#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于”#”的使用，注释符”#”的这种特性值得我们注意，如果我们这样定义一个变量：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dir := /foo/bar # directory to put the frobs in&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;dir这个变量的值是”/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录–”$(dir)/file”那么就完蛋了。&lt;/p&gt;
&lt;p&gt;还有一个比较有用的操作符是”?=”，先看示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FOO ?= bar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其含义是，如果FOO没有被定义过，那么变量FOO的值就是”bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifeq ($(origin FOO), undefined)&amp;#10;&amp;#10;FOO = bar&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;三、变量高级用法&quot;&gt;&lt;a href=&quot;#三、变量高级用法&quot; class=&quot;headerlink&quot; title=&quot;三、变量高级用法&quot;&gt;&lt;/a&gt;三、变量高级用法&lt;/h4&gt;&lt;p&gt;这里介绍两种变量的高级使用方法，第一种是变量值的替换。&lt;/p&gt;
&lt;p&gt;我们可以替换变量中的共有的部分，其格式是”$(var:a=b)”或是”${var:a=b}”，其意思是，把变量”var”中所有以”a”字串”结尾”的”a”替换成”b”字串。这里的”结尾”意思是”空格”或是”结束符”。&lt;/p&gt;
&lt;p&gt;还是看一个示例吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo := a.o b.o c.o&amp;#10;&amp;#10;bar := $(foo:.o=.c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个示例中，我们先定义了一个”$(foo)”变量，而第二行的意思是把”$(foo)”中所有以”.o”字串”结尾”全部替换成”.c”，所以我们的”$(bar)”的值就是”a.c b.c c.c”。&lt;/p&gt;
&lt;p&gt;另外一种变量替换的技术是以”静态模式”（参见前面章节）定义的，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo := a.o b.o c.o&amp;#10;&amp;#10;bar := $(foo:%.o=%.c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这依赖于被替换字串中的有相同的模式，模式中必须包含一个”%”字符，这个例子同样让$(bar)变量的值为”a.c b.c c.c”。&lt;/p&gt;
&lt;p&gt;第二种高级用法是–”把变量的值再当成变量”。先看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = y&amp;#10;&amp;#10;y = z&amp;#10;&amp;#10;a := $($(x))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，$(x)的值是”y”，所以$($(x))就是$(y)，于是$(a)的值就是”z”。（注意，是”x=y”，而不是”x=$(y)”）&lt;/p&gt;
&lt;p&gt;我们还可以使用更多的层次：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = y&amp;#10;&amp;#10;y = z&amp;#10;&amp;#10;z = u&amp;#10;&amp;#10;a := $($($(x)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的$(a)的值是”u”，相关的推导留给读者自己去做吧。&lt;/p&gt;
&lt;p&gt;让我们再复杂一点，使用上”在变量定义中使用变量”的第一个方式，来看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = $(y)&amp;#10;&amp;#10;y = z&amp;#10;&amp;#10;z = Hello&amp;#10;&amp;#10;a := $($(x))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的$($(x))被替换成了$($(y))，因为$(y)值是”z”，所以，最终结果是：a:=$(z)，也就是”Hello”。&lt;/p&gt;
&lt;p&gt;再复杂一点，我们再加上函数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = variable1&amp;#10;&amp;#10;variable2 := Hello&amp;#10;&amp;#10;y = $(subst 1,2,$(x))&amp;#10;&amp;#10;z = y&amp;#10;&amp;#10;a := $($($(z)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中，”$($($(z)))”扩展为”$($(y))”，而其再次被扩展为”$($(subst 1,2,$(x)))”。$(x)的值是”variable1”，subst函数把”variable1”中的所有”1”字串替换成”2”字串，于是，”variable1”变成”variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值– “Hello”。（喔，好不容易）&lt;/p&gt;
&lt;p&gt;在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;first_second = Hello&amp;#10;&amp;#10;a = first&amp;#10;&amp;#10;b = second&amp;#10;&amp;#10;all = $($a_$b)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的”$a_$b”组成了”first_second”，于是，$(all)的值就是”Hello”。&lt;/p&gt;
&lt;p&gt;再来看看结合第一种技术的例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a_objects := a.o b.o c.o&amp;#10;&amp;#10;1_objects := 1.o 2.o 3.o&amp;#10;&amp;#10;sources := $($(a1)_objects:.o=.c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中，如果$(a1)的值是”a”的话，那么，$(sources)的值就是”a.c b.c c.c”；如果$(a1)的值是”1”，那么$(sources)的值是”1.c 2.c 3.c”。&lt;/p&gt;
&lt;p&gt;再来看一个这种技术和”函数”与”条件语句”一同使用的例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifdef do_sort&amp;#10;&amp;#10;func := sort&amp;#10;&amp;#10;else&amp;#10;&amp;#10;func := strip&amp;#10;&amp;#10;endif&amp;#10;&amp;#10;bar := a d b g q c&amp;#10;&amp;#10;foo := $($(func) $(bar))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个示例中，如果定义了”do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是”a b c d g q”，而如果没有定义”do_sort”，那么：foo := $(sort a d b g q c)，调用的就是strip函数。&lt;/p&gt;
&lt;p&gt;当然，”把变量的值再当成变量”这种技术，同样可以用在操作符的左边：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dir = foo&amp;#10;&amp;#10;$(dir)_sources := $(wildcard $(dir)/*.c)&amp;#10;&amp;#10;define $(dir)_print&amp;#10;&amp;#10;lpr $($(dir)_sources)&amp;#10;&amp;#10;endef&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中定义了三个变量：”dir”，”foo_sources”和”foo_print”。&lt;/p&gt;
&lt;h4 id=&quot;四、追加变量值&quot;&gt;&lt;a href=&quot;#四、追加变量值&quot; class=&quot;headerlink&quot; title=&quot;四、追加变量值&quot;&gt;&lt;/a&gt;四、追加变量值&lt;/h4&gt;&lt;p&gt;我们可以使用”+=”操作符给变量追加值，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = main.o foo.o bar.o utils.o&amp;#10;&amp;#10;objects += another.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;于是，我们的$(objects)值变成：”main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）&lt;/p&gt;
&lt;p&gt;使用”+=”操作符，可以模拟为下面的这种例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects = main.o foo.o bar.o utils.o&amp;#10;&amp;#10;objects := $(objects) another.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所不同的是，用”+=”更为简洁。&lt;/p&gt;
&lt;p&gt;如果变量之前没有定义过，那么，”+=”会自动变成”=”，如果前面有变量定义，那么”+=”会继承于前次操作的赋值符。如果前一次的是”:=”，那么”+=”会以”:=”作为其赋值符，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;variable := value&amp;#10;&amp;#10;variable += more&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;等价于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;variable := value&amp;#10;&amp;#10;variable := $(variable) more&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但如果是这种情况：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;variable = value&amp;#10;&amp;#10;variable += more&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于前次的赋值符是”=”，所以”+=”也会以”=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。&lt;/p&gt;
&lt;h4 id=&quot;五、override-指示符&quot;&gt;&lt;a href=&quot;#五、override-指示符&quot; class=&quot;headerlink&quot; title=&quot;五、override 指示符&quot;&gt;&lt;/a&gt;五、override 指示符&lt;/h4&gt;&lt;p&gt;如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用”override”指示符。其语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override &amp;#60;variable&amp;#62; = &amp;#60;value&amp;#62;&amp;#10;&amp;#10;override &amp;#60;variable&amp;#62; := &amp;#60;value&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，你还可以追加：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override &amp;#60;variable&amp;#62; += &amp;#60;more text&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override define foo&amp;#10;&amp;#10;bar&amp;#10;&amp;#10;endef&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;六、多行变量&quot;&gt;&lt;a href=&quot;#六、多行变量&quot; class=&quot;headerlink&quot; title=&quot;六、多行变量&quot;&gt;&lt;/a&gt;六、多行变量&lt;/h4&gt;&lt;p&gt;还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过”命令包”的技术就是利用这个关键字）。&lt;/p&gt;
&lt;p&gt;define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和”=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。&lt;/p&gt;
&lt;p&gt;下面的这个示例展示了define的用法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define two-lines&amp;#10;&amp;#10;echo foo&amp;#10;&amp;#10;echo $(bar)&amp;#10;&amp;#10;endef&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;七、环境变量&quot;&gt;&lt;a href=&quot;#七、环境变量&quot; class=&quot;headerlink&quot; title=&quot;七、环境变量&quot;&gt;&lt;/a&gt;七、环境变量&lt;/h4&gt;&lt;p&gt;make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了”-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）&lt;/p&gt;
&lt;p&gt;因此，如果我们在环境变量中设置了”CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像”全局变量”和”局部变量”的特性。&lt;/p&gt;
&lt;p&gt;当make嵌套调用时（参见前面的”嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）&lt;/p&gt;
&lt;p&gt;当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。&lt;/p&gt;
&lt;h4 id=&quot;八、目标变量&quot;&gt;&lt;a href=&quot;#八、目标变量&quot; class=&quot;headerlink&quot; title=&quot;八、目标变量&quot;&gt;&lt;/a&gt;八、目标变量&lt;/h4&gt;&lt;p&gt;前面我们所讲的在Makefile中定义的变量都是”全局变量”，在整个文件，我们都可以访问这些变量。当然，”自动化变量”除外，如”$&amp;lt;”等这种类量的自动化变量就属于”规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。&lt;/p&gt;
&lt;p&gt;当然，我样同样可以为某个目标设置局部变量，这种变量被称为”Target-specific Variable”，它可以和”全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。&lt;/p&gt;
&lt;p&gt;其语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;target ...&amp;#62; : &amp;#60;variable-assignment&amp;#62;&amp;#10;&amp;#10;&amp;#60;target ...&amp;#62; : overide &amp;#60;variable-assignment&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;variable-assignment&amp;gt;可以是前面讲过的各种赋值表达式，如”=”、”:=”、”+=”或是”？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。&lt;/p&gt;
&lt;p&gt;这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;prog : CFLAGS = -g&amp;#10;&amp;#10;prog : prog.o foo.o bar.o&amp;#10;&amp;#10;&amp;#9;$(CC) $(CFLAGS) prog.o foo.o bar.o&amp;#10;&amp;#10;prog.o : prog.c&amp;#10;&amp;#10;&amp;#9;$(CC) $(CFLAGS) prog.c&amp;#10;&amp;#10;foo.o : foo.c&amp;#10;&amp;#10;&amp;#9;$(CC) $(CFLAGS) foo.c&amp;#10;&amp;#10;bar.o : bar.c&amp;#10;&amp;#10;&amp;#9;$(CC) $(CFLAGS) bar.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是”-g”。&lt;/p&gt;
&lt;h4 id=&quot;九、模式变量&quot;&gt;&lt;a href=&quot;#九、模式变量&quot; class=&quot;headerlink&quot; title=&quot;九、模式变量&quot;&gt;&lt;/a&gt;九、模式变量&lt;/h4&gt;&lt;p&gt;在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种”模式”，可以把变量定义在符合这种模式的所有目标上。&lt;/p&gt;
&lt;p&gt;我们知道，make的”模式”一般是至少含有一个”%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;%.o : CFLAGS = -O&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样，模式变量的语法和”目标变量”一样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;pattern ...&amp;#62; : &amp;#60;variable-assignment&amp;#62;&amp;#10;&amp;#10;&amp;#60;pattern ...&amp;#62; : override &amp;#60;variable-assignment&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;override同样是针对于系统环境传入的变量，或是make命令行指定的变量。&lt;/p&gt;
&lt;h3 id=&quot;使用条件判断&quot;&gt;&lt;a href=&quot;#使用条件判断&quot; class=&quot;headerlink&quot; title=&quot;使用条件判断&quot;&gt;&lt;/a&gt;使用条件判断&lt;/h3&gt;&lt;p&gt;使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以&lt;br&gt;是比较变量的值，或是比较变量和常量的值。&lt;/p&gt;
&lt;h4 id=&quot;一、示例&quot;&gt;&lt;a href=&quot;#一、示例&quot; class=&quot;headerlink&quot; title=&quot;一、示例&quot;&gt;&lt;/a&gt;一、示例&lt;/h4&gt;&lt;p&gt;下面的例子，判断$(CC)变量是否”gcc”，如果是的话，则使用GNU函数编译目标。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;libs_for_gcc = -lgnu&amp;#10;&amp;#10;normal_libs =&amp;#10;&amp;#10;foo: $(objects)&amp;#10;&amp;#10;ifeq ($(CC),gcc)&amp;#10;&amp;#10;&amp;#9;$(CC) -o foo $(objects) $(libs_for_gcc)&amp;#10;&amp;#10;else&amp;#10;&amp;#10;&amp;#9;$(CC) -o foo $(objects) $(normal_libs)&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，在上面示例的这个规则中，目标”foo”可以根据变量”$(CC)”值来选取不同的函数库来编译程序。&lt;/p&gt;
&lt;p&gt;我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。&lt;/p&gt;
&lt;p&gt;当我们的变量$(CC)值是”gcc”时，目标foo的规则是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo: $(objects)&amp;#10;&amp;#10;&amp;#9;$(CC) -o foo $(objects) $(libs_for_gcc)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而当我们的变量$(CC)值不是”gcc”时（比如”cc”），目标foo的规则是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo: $(objects)&amp;#10;&amp;#10;&amp;#9;$(CC) -o foo $(objects) $(normal_libs)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，我们还可以把上面的那个例子写得更简洁一些：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;libs_for_gcc = -lgnu&amp;#10;&amp;#10;normal_libs =&amp;#10;&amp;#10;ifeq ($(CC),gcc)&amp;#10;&amp;#10;libs=$(libs_for_gcc)&amp;#10;&amp;#10;else&amp;#10;&amp;#10;libs=$(normal_libs)&amp;#10;&amp;#10;endif&amp;#10;&amp;#10;foo: $(objects)&amp;#10;&amp;#10;&amp;#9;$(CC) -o foo $(objects) $(libs)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;二、语法&quot;&gt;&lt;a href=&quot;#二、语法&quot; class=&quot;headerlink&quot; title=&quot;二、语法&quot;&gt;&lt;/a&gt;二、语法&lt;/h4&gt;&lt;p&gt;条件表达式的语法为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;conditional-directive&amp;#62;&amp;#10;&amp;#10;&amp;#60;text-if-true&amp;#62;&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以及：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;conditional-directive&amp;#62;&amp;#10;&amp;#10;&amp;#60;text-if-true&amp;#62;&amp;#10;&amp;#10;else&amp;#10;&amp;#10;&amp;#60;text-if-false&amp;#62;&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中&amp;lt;conditional-directive&amp;gt;表示条件关键字，如”ifeq”。这个关键字有四个。&lt;/p&gt;
&lt;p&gt;第一个是我们前面所见过的”ifeq”&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifeq (&amp;#60;arg1&amp;#62;, &amp;#60;arg2&amp;#62; )&amp;#10;&amp;#10;ifeq &amp;#39;&amp;#60;arg1&amp;#62;&amp;#39; &amp;#39;&amp;#60;arg2&amp;#62;&amp;#39;&amp;#10;&amp;#10;ifeq &amp;#34;&amp;#60;arg1&amp;#62;&amp;#34; &amp;#34;&amp;#60;arg2&amp;#62;&amp;#34;&amp;#10;&amp;#10;ifeq &amp;#34;&amp;#60;arg1&amp;#62;&amp;#34; &amp;#39;&amp;#60;arg2&amp;#62;&amp;#39;&amp;#10;&amp;#10;ifeq &amp;#39;&amp;#60;arg1&amp;#62;&amp;#39; &amp;#34;&amp;#60;arg2&amp;#62;&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;比较参数”arg1”和”arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifeq ($(strip $(foo)),)&amp;#10;&amp;#10;&amp;#60;text-if-empty&amp;#62;&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个示例中使用了”strip”函数，如果这个函数的返回值是空（Empty），那么&amp;lt;text-if-empty&amp;gt;就生效。&lt;/p&gt;
&lt;p&gt;第二个条件关键字是”ifneq”。语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifneq (&amp;#60;arg1&amp;#62;, &amp;#60;arg2&amp;#62; )&amp;#10;&amp;#10;ifneq &amp;#39;&amp;#60;arg1&amp;#62;&amp;#39; &amp;#39;&amp;#60;arg2&amp;#62;&amp;#39;&amp;#10;&amp;#10;ifneq &amp;#34;&amp;#60;arg1&amp;#62;&amp;#34; &amp;#34;&amp;#60;arg2&amp;#62;&amp;#34;&amp;#10;&amp;#10;ifneq &amp;#34;&amp;#60;arg1&amp;#62;&amp;#34; &amp;#39;&amp;#60;arg2&amp;#62;&amp;#39;&amp;#10;&amp;#10;ifneq &amp;#39;&amp;#60;arg1&amp;#62;&amp;#39; &amp;#34;&amp;#60;arg2&amp;#62;&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其比较参数”arg1”和”arg2”的值是否相同，如果不同，则为真。和”ifeq”类似。&lt;/p&gt;
&lt;p&gt;第三个条件关键字是”ifdef”。语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifdef &amp;#60;variable-name&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果变量&amp;lt;variable-name&amp;gt;的值非空，那到表达式为真。否则，表达式为假。当然，&amp;lt;variable-name&amp;gt;同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：&lt;/p&gt;
&lt;p&gt;示例一：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bar =&amp;#10;&amp;#10;foo = $(bar)&amp;#10;&amp;#10;ifdef foo&amp;#10;&amp;#10;frobozz = yes&amp;#10;&amp;#10;else&amp;#10;&amp;#10;frobozz = no&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例二：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo =&amp;#10;&amp;#10;ifdef foo&amp;#10;&amp;#10;frobozz = yes&amp;#10;&amp;#10;else&amp;#10;&amp;#10;frobozz = no&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一个例子中，”$(frobozz)”值是”yes”，第二个则是”no”。&lt;/p&gt;
&lt;p&gt;第四个条件关键字是”ifndef”。其语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifndef &amp;#60;variable-name&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个我就不多说了，和”ifdef”是相反的意思。&lt;/p&gt;
&lt;p&gt;在&amp;lt;conditional-directive&amp;gt;这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符”#”同样也是安全的。”else”和”endif”也一样，只要不是以[Tab]键开始就行了。&lt;/p&gt;
&lt;p&gt;特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如”$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。&lt;/p&gt;
&lt;p&gt;而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。&lt;/p&gt;
&lt;h3 id=&quot;使用函数&quot;&gt;&lt;a href=&quot;#使用函数&quot; class=&quot;headerlink&quot; title=&quot;使用函数&quot;&gt;&lt;/a&gt;使用函数&lt;/h3&gt;&lt;p&gt;在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。&lt;/p&gt;
&lt;h4 id=&quot;一、函数的调用语法&quot;&gt;&lt;a href=&quot;#一、函数的调用语法&quot; class=&quot;headerlink&quot; title=&quot;一、函数的调用语法&quot;&gt;&lt;/a&gt;一、函数的调用语法&lt;/h4&gt;&lt;p&gt;函数调用，很像变量的使用，也是以”$”来标识的，其语法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;#60;function&amp;#62; &amp;#60;arguments&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或是&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$&amp;#123;&amp;#60;function&amp;#62; &amp;#60;arguments&amp;#62;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里，&amp;lt;function&amp;gt;就是函数名，make支持的函数不多。&amp;lt;arguments&amp;gt;是函数的参数，参数间以逗号”,”分隔，而函数名和参数之间以”空格”分隔。函数调用以”$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用”$(subst a,b,$(x))”这样的形式，而不是”$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。&lt;/p&gt;
&lt;p&gt;还是来看一个示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;comma:= ,&amp;#10;&amp;#10;empty:=&amp;#10;&amp;#10;space:= $(empty) $(empty)&amp;#10;&amp;#10;foo:= a b c&amp;#10;&amp;#10;bar:= $(subst $(space),$(comma),$(foo))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是”a b c”，$(bar)的定义用，调用了函数”subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是”a,b,c”。&lt;/p&gt;
&lt;h4 id=&quot;二、字符串处理函数&quot;&gt;&lt;a href=&quot;#二、字符串处理函数&quot; class=&quot;headerlink&quot; title=&quot;二、字符串处理函数&quot;&gt;&lt;/a&gt;二、字符串处理函数&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(subst &amp;#38;lt;from&amp;#38;gt;,&amp;#38;lt;to&amp;#38;gt;,&amp;#38;lt;text&amp;#38;gt; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;名称：字符串替换函数–subst。&lt;/p&gt;
&lt;p&gt;功能：把字串&amp;lt;text&amp;gt;中的&amp;lt;from&amp;gt;字符串替换成&amp;lt;to&amp;gt;。&lt;/p&gt;
&lt;p&gt;返回：函数返回被替换过后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(subst ee,EE,feet on the street)，把”feet on the street”中的”ee”替换成”EE”，返回结果是”fEEt on the strEEt”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(patsubst &amp;#60;pattern&amp;#62;,&amp;#60;replacement&amp;#62;,&amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：模式字符串替换函数–patsubst。&lt;/p&gt;
&lt;p&gt;功能：查找&amp;lt;text&amp;gt;中的单词（单词以”空格”、”Tab”或”回车””换行”分隔）是否符合模式&amp;lt;pattern&amp;gt;，如果匹配的话，则以&amp;lt;replacement&amp;gt;替换。这里，&amp;lt;pattern&amp;gt;可以包括通配符”%”，表示任意长度的字串。如果&amp;lt;replacement&amp;gt;中也包含”%”，那么，&amp;lt;replacement&amp;gt;中的这个”%”将是&amp;lt;pattern&amp;gt;中的那个”%”所代表的字串。（可以用”\”来转义，以”\%”来表示真实含义的”%”字符）&lt;/p&gt;
&lt;p&gt;返回：函数返回被替换过后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(patsubst %.c,%.o,x.c.c bar.c)把字串”x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是”x.c.o bar.o”&lt;/p&gt;
&lt;p&gt;备注：这和我们前面”变量章节”说过的相关知识有点相似。如：&lt;br&gt;&lt;code&gt;$(var:&amp;amp;lt;pattern&amp;amp;gt;=&amp;amp;lt;replacement&amp;amp;gt; )&lt;/code&gt;相当于&lt;code&gt;$(patsubst &amp;amp;lt;pattern&amp;amp;gt;,&amp;amp;lt;replacement&amp;amp;gt;,$(var))&lt;/code&gt;，而&lt;code&gt;$(var: &amp;amp;lt;suffix&amp;amp;gt;=&amp;amp;lt;replacement&amp;amp;gt; )&lt;/code&gt;则相当于&lt;code&gt;$(patsubst %&amp;amp;lt;suffix&amp;amp;gt;,%&amp;amp;lt;replacement&amp;amp;gt;,$(var))&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如有：objects = foo.o bar.o baz.o，那么，”$(objects:.o=.c)”和”$(patsubst %.o,%.c,$(objects))”是一样的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(strip &amp;#60;string&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：去空格函数–strip。&lt;/p&gt;
&lt;p&gt;功能：去掉&amp;lt;string&amp;gt;字串中开头和结尾的空字符。&lt;/p&gt;
&lt;p&gt;返回：返回被去掉空格的字符串值。&lt;/p&gt;
&lt;p&gt;示例：$(strip a b c )把字串”a b c “去到开头和结尾的空格，结果是”a b c”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(findstring &amp;#60;find&amp;#62;,&amp;#60;in&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：查找字符串函数–findstring。&lt;/p&gt;
&lt;p&gt;功能：在字串&amp;lt;in&amp;gt;中查找&amp;lt;find&amp;gt;字串。&lt;/p&gt;
&lt;p&gt;返回：如果找到，那么返回&amp;lt;find&amp;gt;，否则返回空字符串。&lt;/p&gt;
&lt;p&gt;示例：$(findstring a,a b c)返回”a”字符串，$(findstring a,b c)返回””字符串（空字符串）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(filter &amp;#60;pattern...&amp;#62;,&amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：过滤函数–filter。&lt;/p&gt;
&lt;p&gt;功能：以&amp;lt;pattern&amp;gt;模式过滤&amp;lt;text&amp;gt;字符串中的单词，保留符合模式&amp;lt;pattern&amp;gt;的单词。可以有多个模式。&lt;/p&gt;
&lt;p&gt;返回：返回符合模式&amp;lt;pattern&amp;gt;的字串。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sources := foo.c bar.c baz.s ugh.h&amp;#10;&amp;#10;foo: $(sources)&amp;#10;&amp;#10;&amp;#9;cc $(filter %.c %.s,$(sources)) -o foo&amp;#10;&amp;#10;$(filter %.c %.s,$(sources))&amp;#36820;&amp;#22238;&amp;#30340;&amp;#20540;&amp;#26159;&amp;#34;foo.c bar.c baz.s&amp;#34;&amp;#12290;&amp;#10;&amp;#10;$(filter-out &amp;#60;pattern...&amp;#62;,&amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：反过滤函数–filter-out。&lt;/p&gt;
&lt;p&gt;功能：以&amp;lt;pattern&amp;gt;模式过滤&amp;lt;text&amp;gt;字符串中的单词，去除符合模式&amp;lt;pattern&amp;gt;的单词。可以有多个模式。&lt;/p&gt;
&lt;p&gt;返回：返回不符合模式&amp;lt;pattern&amp;gt;的字串。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objects=main1.o foo.o main2.o bar.o&amp;#10;&amp;#10;mains=main1.o main2.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;$(filter-out $(mains),$(objects)) 返回值是”foo.o bar.o”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(sort &amp;#60;list&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：排序函数–sort。&lt;/p&gt;
&lt;p&gt;功能：给字符串&amp;lt;list&amp;gt;中的单词排序（升序）。&lt;/p&gt;
&lt;p&gt;返回：返回排序后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(sort foo bar lose)返回”bar foo lose” 。&lt;/p&gt;
&lt;p&gt;备注：sort函数会去掉&amp;lt;list&amp;gt;中相同的单词。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(word &amp;#60;n&amp;#62;,&amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：取单词函数–word。&lt;/p&gt;
&lt;p&gt;功能：取字符串&amp;lt;text&amp;gt;中第&amp;lt;n&amp;gt;个单词。（从一开始）&lt;/p&gt;
&lt;p&gt;返回：返回字符串&amp;lt;text&amp;gt;中第&amp;lt;n&amp;gt;个单词。如果&amp;lt;n&amp;gt;比&amp;lt;text&amp;gt;中的单词数要大，那么返回空字符串。&lt;/p&gt;
&lt;p&gt;示例：$(word 2, foo bar baz)返回值是”bar”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(wordlist &amp;#60;s&amp;#62;,&amp;#60;e&amp;#62;,&amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：取单词串函数–wordlist。&lt;/p&gt;
&lt;p&gt;功能：从字符串&amp;lt;text&amp;gt;中取从&amp;lt;s&amp;gt;开始到&amp;lt;e&amp;gt;的单词串。&amp;lt;s&amp;gt;和&amp;lt;e&amp;gt;是一个数字。&lt;/p&gt;
&lt;p&gt;返回：返回字符串&amp;lt;text&amp;gt;中从&amp;lt;s&amp;gt;到&amp;lt;e&amp;gt;的单词字串。如果&amp;lt;s&amp;gt;比&amp;lt;text&amp;gt;中的单词数要大，那么返回空字符串。如果&amp;lt;e&amp;gt;大于&amp;lt;text&amp;gt;的单词数，那么返回从&amp;lt;s&amp;gt;开始，到&amp;lt;text&amp;gt;结束的单词串。&lt;/p&gt;
&lt;p&gt;示例： $(wordlist 2, 3, foo bar baz)返回值是”bar baz”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(words &amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：单词个数统计函数–words。&lt;/p&gt;
&lt;p&gt;功能：统计&amp;lt;text&amp;gt;中字符串中的单词个数。&lt;/p&gt;
&lt;p&gt;返回：返回&amp;lt;text&amp;gt;中的单词数。&lt;/p&gt;
&lt;p&gt;示例：$(words, foo bar baz)返回值是”3”。&lt;/p&gt;
&lt;p&gt;备注：如果我们要取&amp;lt;text&amp;gt;中最后的一个单词，我们可以这样：$(word $(words &amp;lt;text&amp;gt; ),&amp;lt;text&amp;gt; )。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(firstword &amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：首单词函数–firstword。&lt;/p&gt;
&lt;p&gt;功能：取字符串&amp;lt;text&amp;gt;中的第一个单词。&lt;/p&gt;
&lt;p&gt;返回：返回字符串&amp;lt;text&amp;gt;的第一个单词。&lt;/p&gt;
&lt;p&gt;示例：$(firstword foo bar)返回值是”foo”。&lt;/p&gt;
&lt;p&gt;备注：这个函数可以用word函数来实现：$(word 1,&amp;lt;text&amp;gt; )。&lt;/p&gt;
&lt;p&gt;以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用”VPATH”变量来指定”依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果我们的”$(VPATH)”值是”src:../headers”，那么”$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回”-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。&lt;/p&gt;
&lt;h4 id=&quot;三、文件名操作函数&quot;&gt;&lt;a href=&quot;#三、文件名操作函数&quot; class=&quot;headerlink&quot; title=&quot;三、文件名操作函数&quot;&gt;&lt;/a&gt;三、文件名操作函数&lt;/h4&gt;&lt;p&gt;下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(dir &amp;#60;names...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：取目录函数–dir。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&amp;lt;names&amp;gt;中取出目录部分。目录部分是指最后一个反斜杠（”/“）之前的部分。如果没有反斜杠，那么返回”./“。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&amp;lt;names&amp;gt;的目录部分。&lt;/p&gt;
&lt;p&gt;示例： $(dir src/foo.c hacks)返回值是”src/ ./“。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(notdir &amp;#60;names...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：取文件函数–notdir。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&amp;lt;names&amp;gt;中取出非目录部分。非目录部分是指最后一个反斜杠（”/“）之后的部分。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&amp;lt;names&amp;gt;的非目录部分。&lt;/p&gt;
&lt;p&gt;示例： $(notdir src/foo.c hacks)返回值是”foo.c hacks”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(suffix &amp;#60;names...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：取后缀函数–suffix。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&amp;lt;names&amp;gt;中取出各个文件名的后缀。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&amp;lt;names&amp;gt;的后缀序列，如果文件没有后缀，则返回空字串。&lt;/p&gt;
&lt;p&gt;示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是”.c .c”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(basename &amp;#60;names...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：取前缀函数–basename。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&amp;lt;names&amp;gt;中取出各个文件名的前缀部分。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&amp;lt;names&amp;gt;的前缀序列，如果文件没有前缀，则返回空字串。&lt;/p&gt;
&lt;p&gt;示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是”src/foo src-1.0/bar hacks”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(addsuffix &amp;#60;suffix&amp;#62;,&amp;#60;names...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：加后缀函数–addsuffix。&lt;/p&gt;
&lt;p&gt;功能：把后缀&amp;lt;suffix&amp;gt;加到&amp;lt;names&amp;gt;中的每个单词后面。&lt;/p&gt;
&lt;p&gt;返回：返回加过后缀的文件名序列。&lt;/p&gt;
&lt;p&gt;示例：$(addsuffix .c,foo bar)返回值是”foo.c bar.c”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(addprefix &amp;#60;prefix&amp;#62;,&amp;#60;names...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：加前缀函数–addprefix。&lt;/p&gt;
&lt;p&gt;功能：把前缀&amp;lt;prefix&amp;gt;加到&amp;lt;names&amp;gt;中的每个单词后面。&lt;/p&gt;
&lt;p&gt;返回：返回加过前缀的文件名序列。&lt;/p&gt;
&lt;p&gt;示例：$(addprefix src/,foo bar)返回值是”src/foo src/bar”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(join &amp;#60;list1&amp;#62;,&amp;#60;list2&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;名称：连接函数–join。&lt;/p&gt;
&lt;p&gt;功能：把&amp;lt;list2&amp;gt;中的单词对应地加到&amp;lt;list1&amp;gt;的单词后面。如果&amp;lt;list1&amp;gt;的单词个数要比&amp;lt;list2&amp;gt;的多，那么，&amp;lt;list1&amp;gt;中的多出来的单词将保持原样。如果&amp;lt;list2&amp;gt;的单词个数要比&amp;lt;list1&amp;gt;多，那么，&amp;lt;list2&amp;gt;多出来的单词将被复制到&amp;lt;list2&amp;gt;中。&lt;/p&gt;
&lt;p&gt;返回：返回连接过后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(join aaa bbb , 111 222 333)返回值是”aaa111 bbb222 333”。&lt;/p&gt;
&lt;h4 id=&quot;四、foreach-函数&quot;&gt;&lt;a href=&quot;#四、foreach-函数&quot; class=&quot;headerlink&quot; title=&quot;四、foreach 函数&quot;&gt;&lt;/a&gt;四、foreach 函数&lt;/h4&gt;&lt;p&gt;foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(foreach &amp;#60;var&amp;#62;,&amp;#60;list&amp;#62;,&amp;#60;text&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个函数的意思是，把参数&amp;lt;list&amp;gt;中的单词逐一取出放到参数&amp;lt;var&amp;gt;所指定的变量中，然后再执行&amp;lt;text&amp;gt;所包含的表达式。每一次&amp;lt;text&amp;gt;会返回一个字符串，循环过程中，&amp;lt;text&amp;gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&amp;lt;text&amp;gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。&lt;/p&gt;
&lt;p&gt;所以，&amp;lt;var&amp;gt;最好是一个变量名，&amp;lt;list&amp;gt;可以是一个表达式，而&amp;lt;text&amp;gt;中一般会使用&amp;lt;var&amp;gt;这个参数来依次枚举&amp;lt;list&amp;gt;中的单词。举个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;names := a b c d&amp;#10;&amp;#10;files := $(foreach n,$(names),$(n).o)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的例子中，$(name)中的单词会被挨个取出，并存到变量”n”中，”$(n).o”每次根据”$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是”a.o b.o c.o d.o”。&lt;/p&gt;
&lt;p&gt;注意，foreach中的&amp;lt;var&amp;gt;参数是一个临时的局部变量，foreach函数执行完后，参数&amp;lt;var&amp;gt;的变量将不在作用，其作用域只在foreach函数当中。&lt;/p&gt;
&lt;h4 id=&quot;五、if-函数&quot;&gt;&lt;a href=&quot;#五、if-函数&quot; class=&quot;headerlink&quot; title=&quot;五、if 函数&quot;&gt;&lt;/a&gt;五、if 函数&lt;/h4&gt;&lt;p&gt;if函数很像GNU的make所支持的条件语句–ifeq（参见前面所述的章节），if函数的语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(if &amp;#60;condition&amp;#62;,&amp;#60;then-part&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或是&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(if &amp;#60;condition&amp;#62;,&amp;#60;then-part&amp;#62;,&amp;#60;else-part&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，if函数可以包含”else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。&amp;lt;condition&amp;gt;参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&amp;lt;then-part&amp;gt;会被计算，否则&amp;lt;else-part&amp;gt; 会被计算。&lt;/p&gt;
&lt;p&gt;而if函数的返回值是，如果&amp;lt;condition&amp;gt;为真（非空字符串），那个&amp;lt;then- part&amp;gt;会是整个函数的返回值，如果&amp;lt;condition&amp;gt;为假（空字符串），那么&amp;lt;else-part&amp;gt;会是整个函数的返回值，此时如果&amp;lt;else-part&amp;gt;没有被定义，那么，整个函数返回空字串。&lt;/p&gt;
&lt;p&gt;所以，&amp;lt;then-part&amp;gt;和&amp;lt;else-part&amp;gt;只会有一个被计算。&lt;/p&gt;
&lt;h4 id=&quot;六、call函数&quot;&gt;&lt;a href=&quot;#六、call函数&quot; class=&quot;headerlink&quot; title=&quot;六、call函数&quot;&gt;&lt;/a&gt;六、call函数&lt;/h4&gt;&lt;p&gt;call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(call &amp;#60;expression&amp;#62;,&amp;#60;parm1&amp;#62;,&amp;#60;parm2&amp;#62;,&amp;#60;parm3&amp;#62;...)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当 make执行这个函数时，&amp;lt;expression&amp;gt;参数中的变量，如$(1)，$(2)，$(3)等，会被参数&amp;lt;parm1&amp;gt;，&amp;lt;parm2&amp;gt;，&amp;lt;parm3&amp;gt;依次取代。而&amp;lt;expression&amp;gt;的返回值就是 call函数的返回值。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;reverse = $(1) $(2)&amp;#10;&amp;#10;foo = $(call reverse,a,b)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么，foo的值就是”a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;reverse = $(2) $(1)&amp;#10;&amp;#10;foo = $(call reverse,a,b)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时的foo的值就是”b a”。&lt;/p&gt;
&lt;h4 id=&quot;七、origin函数&quot;&gt;&lt;a href=&quot;#七、origin函数&quot; class=&quot;headerlink&quot; title=&quot;七、origin函数&quot;&gt;&lt;/a&gt;七、origin函数&lt;/h4&gt;&lt;p&gt;origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(origin &amp;#60;variable&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意，&amp;lt;variable&amp;gt;是变量的名字，不应该是引用。所以你最好不要在&amp;lt;variable&amp;gt;中使用”$”字符。Origin函数会以其返回值来告诉你这个变量的”出生情况”，下面，是origin函数的返回值:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;undefined&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;从来没有定义过，origin函数返回这个值”undefined”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;是一个默认的定义，比如”CC”这个变量，这种变量我们将在后面讲述。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;environment&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;是一个环境变量，并且当Makefile被执行时，”-e”参数没有被打开。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;file&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;这个变量被定义在Makefile中。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;command line&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;这个变量是被命令行定义的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;override&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;是被override指示符重新定义的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#34;automatic&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;variable&amp;gt;是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。&lt;/p&gt;
&lt;p&gt;这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量”bletch”，而我们的环境中也有一个环境变量”bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifdef bletch&amp;#10;&amp;#10;ifeq &amp;#34;$(origin bletch)&amp;#34; &amp;#34;environment&amp;#34;&amp;#10;&amp;#10;bletch = barf, gag, etc.&amp;#10;&amp;#10;endif&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。&lt;/p&gt;
&lt;h4 id=&quot;八、shell函数&quot;&gt;&lt;a href=&quot;#八、shell函数&quot; class=&quot;headerlink&quot; title=&quot;八、shell函数&quot;&gt;&lt;/a&gt;八、shell函数&lt;/h4&gt;&lt;p&gt;shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号”`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;contents := $(shell cat foo)&amp;#10;&amp;#10;files := $(shell echo *.c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。&lt;/p&gt;
&lt;h4 id=&quot;九、控制make的函数&quot;&gt;&lt;a href=&quot;#九、控制make的函数&quot; class=&quot;headerlink&quot; title=&quot;九、控制make的函数&quot;&gt;&lt;/a&gt;九、控制make的函数&lt;/h4&gt;&lt;p&gt;make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(error &amp;#60;text ...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;产生一个致命的错误，&amp;lt;text …&amp;gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：&lt;/p&gt;
&lt;p&gt;示例一：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifdef ERROR_001&amp;#10;&amp;#10;$(error error is $(ERROR_001))&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例二：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ERR = $(error found an error!)&amp;#10;&amp;#10;.PHONY: err&amp;#10;&amp;#10;err: ; $(ERR)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(warning &amp;#60;text ...&amp;#62; )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。&lt;/p&gt;
&lt;h3 id=&quot;make的运行&quot;&gt;&lt;a href=&quot;#make的运行&quot; class=&quot;headerlink&quot; title=&quot;make的运行&quot;&gt;&lt;/a&gt;make的运行&lt;/h3&gt;&lt;p&gt;一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。&lt;/p&gt;
&lt;h4 id=&quot;一、make的退出码&quot;&gt;&lt;a href=&quot;#一、make的退出码&quot; class=&quot;headerlink&quot; title=&quot;一、make的退出码&quot;&gt;&lt;/a&gt;一、make的退出码&lt;/h4&gt;&lt;p&gt;make命令执行后有三个退出码：&lt;/p&gt;
&lt;p&gt;0 – 表示成功执行。&lt;/p&gt;
&lt;p&gt;1 – 如果make运行时出现任何错误，其返回1。&lt;/p&gt;
&lt;p&gt;2 – 如果你使用了make的”-q”选项，并且make使得一些目标不需要更新，那么返回2。&lt;/p&gt;
&lt;p&gt;Make的相关参数我们会在后续章节中讲述。&lt;/p&gt;
&lt;h4 id=&quot;二、指定Makefile&quot;&gt;&lt;a href=&quot;#二、指定Makefile&quot; class=&quot;headerlink&quot; title=&quot;二、指定Makefile&quot;&gt;&lt;/a&gt;二、指定Makefile&lt;/h4&gt;&lt;p&gt;前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件–”GNUmakefile”、”makefile”和”Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。&lt;/p&gt;
&lt;p&gt;当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的”-f”或是”–file”参数（”– makefile”参数也行）。例如，我们有个makefile的名字是”hchen.mk”，那么，我们可以这样来让make来执行这个文件：&lt;/p&gt;
&lt;p&gt;make –f hchen.mk&lt;/p&gt;
&lt;p&gt;如果在make的命令行是，你不只一次地使用了”-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。&lt;/p&gt;
&lt;h4 id=&quot;三、指定目标&quot;&gt;&lt;a href=&quot;#三、指定目标&quot; class=&quot;headerlink&quot; title=&quot;三、指定目标&quot;&gt;&lt;/a&gt;三、指定目标&lt;/h4&gt;&lt;p&gt;一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的”make clean”形式）&lt;/p&gt;
&lt;p&gt;任何在makefile中的目标都可以被指定成终极目标，但是除了以”- “打头，或是包含了”=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。&lt;/p&gt;
&lt;p&gt;有一个make的环境变量叫”MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sources = foo.c bar.c&amp;#10;&amp;#10;ifneq ( $(MAKECMDGOALS),clean)&amp;#10;&amp;#10;include $(sources:.c=.d)&amp;#10;&amp;#10;endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于上面的这个例子，只要我们输入的命令不是”make clean”，那么makefile会自动包含”foo.d”和”bar.d”这两个makefile。&lt;/p&gt;
&lt;p&gt;使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.PHONY: all&amp;#10;&amp;#10;all: prog1 prog2 prog3 prog4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序–”prog1”，”prog2”，”prog3”和”prog4”，我们可以使用”make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行”make”），我们也可以使用”make prog2”来单独编译目标”prog2”。&lt;/p&gt;
&lt;p&gt;即然make可以指定所有makefile中的目标，那么也包括”伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。&lt;/p&gt;
&lt;p&gt;“all”&lt;/p&gt;
&lt;p&gt;这个伪目标是所有目标的目标，其功能一般是编译所有的目标。&lt;/p&gt;
&lt;p&gt;“clean”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是删除所有被make创建的文件。&lt;/p&gt;
&lt;p&gt;“install”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。&lt;/p&gt;
&lt;p&gt;“print”&lt;/p&gt;
&lt;p&gt;这个伪目标的功能是例出改变过的源文件。&lt;/p&gt;
&lt;p&gt;“tar”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是把源程序打包备份。也就是一个tar文件。&lt;/p&gt;
&lt;p&gt;“dist”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。&lt;/p&gt;
&lt;p&gt;“TAGS”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是更新所有的目标，以备完整地重编译使用。&lt;/p&gt;
&lt;p&gt;“check”和”test”&lt;/p&gt;
&lt;p&gt;这两个伪目标一般用来测试makefile的流程。&lt;/p&gt;
&lt;p&gt;当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是–不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。&lt;/p&gt;
&lt;h4 id=&quot;四、检查规则&quot;&gt;&lt;a href=&quot;#四、检查规则&quot; class=&quot;headerlink&quot; title=&quot;四、检查规则&quot;&gt;&lt;/a&gt;四、检查规则&lt;/h4&gt;&lt;p&gt;有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：&lt;/p&gt;
&lt;p&gt;“-n”&lt;/p&gt;
&lt;p&gt;“–just-print”&lt;/p&gt;
&lt;p&gt;“–dry-run”&lt;/p&gt;
&lt;p&gt;“–recon”&lt;/p&gt;
&lt;p&gt;不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。&lt;/p&gt;
&lt;p&gt;“-t”&lt;/p&gt;
&lt;p&gt;“–touch”&lt;/p&gt;
&lt;p&gt;这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。&lt;/p&gt;
&lt;p&gt;“-q”&lt;/p&gt;
&lt;p&gt;“–question”&lt;/p&gt;
&lt;p&gt;这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。&lt;/p&gt;
&lt;p&gt;“-W &amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–what-if=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–assume-new=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–new-file=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和”-n”参数一同使用，来查看这个依赖文件所发生的规则命令。&lt;/p&gt;
&lt;p&gt;另外一个很有意思的用法是结合”-p”和”-v”来输出makefile被执行时的信息（这个将在后面讲述）。&lt;/p&gt;
&lt;h4 id=&quot;五、make的参数&quot;&gt;&lt;a href=&quot;#五、make的参数&quot; class=&quot;headerlink&quot; title=&quot;五、make的参数&quot;&gt;&lt;/a&gt;五、make的参数&lt;/h4&gt;&lt;p&gt;下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。&lt;/p&gt;
&lt;p&gt;“-b”&lt;/p&gt;
&lt;p&gt;“-m”&lt;/p&gt;
&lt;p&gt;这两个参数的作用是忽略和其它版本make的兼容性。&lt;/p&gt;
&lt;p&gt;“-B”&lt;/p&gt;
&lt;p&gt;“–always-make”&lt;/p&gt;
&lt;p&gt;认为所有的目标都需要更新（重编译）。&lt;/p&gt;
&lt;p&gt;“-C &amp;lt;dir&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–directory=&amp;lt;dir&amp;gt;”&lt;/p&gt;
&lt;p&gt;指定读取makefile的目录。如果有多个”-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：”make –C ~hchen/test –C prog”等价于”make –C ~hchen/test/prog”。&lt;/p&gt;
&lt;p&gt;“-debug[=&amp;lt;options&amp;gt;]”&lt;/p&gt;
&lt;p&gt;输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&amp;lt;options&amp;gt;的取值：&lt;/p&gt;
&lt;p&gt;a – 也就是all，输出所有的调试信息。（会非常的多）&lt;/p&gt;
&lt;p&gt;b – 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。&lt;/p&gt;
&lt;p&gt;v – 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。&lt;/p&gt;
&lt;p&gt;i – 也就是implicit，输出所以的隐含规则。&lt;/p&gt;
&lt;p&gt;j – 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。&lt;/p&gt;
&lt;p&gt;m – 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。&lt;/p&gt;
&lt;p&gt;“-d”&lt;/p&gt;
&lt;p&gt;相当于”–debug=a”。&lt;/p&gt;
&lt;p&gt;“-e”&lt;/p&gt;
&lt;p&gt;“–environment-overrides”&lt;/p&gt;
&lt;p&gt;指明环境变量的值覆盖makefile中定义的变量的值。&lt;/p&gt;
&lt;p&gt;“-f=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–file=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–makefile=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;指定需要执行的makefile。&lt;/p&gt;
&lt;p&gt;“-h”&lt;/p&gt;
&lt;p&gt;“–help”&lt;/p&gt;
&lt;p&gt;显示帮助信息。&lt;/p&gt;
&lt;p&gt;“-i”&lt;/p&gt;
&lt;p&gt;“–ignore-errors”&lt;/p&gt;
&lt;p&gt;在执行时忽略所有的错误。&lt;/p&gt;
&lt;p&gt;“-I &amp;lt;dir&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–include-dir=&amp;lt;dir&amp;gt;”&lt;/p&gt;
&lt;p&gt;指定一个被包含makefile的搜索目标。可以使用多个”-I”参数来指定多个目录。&lt;/p&gt;
&lt;p&gt;“-j [&amp;lt;jobsnum&amp;gt;]”&lt;/p&gt;
&lt;p&gt;“–jobs[=&amp;lt;jobsnum&amp;gt;]”&lt;/p&gt;
&lt;p&gt;指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的”-j”参数，那么仅最后一个”-j”才是有效的。（注意这个参数在MS-DOS中是无用的）&lt;/p&gt;
&lt;p&gt;“-k”&lt;/p&gt;
&lt;p&gt;“–keep-going”&lt;/p&gt;
&lt;p&gt;出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。&lt;/p&gt;
&lt;p&gt;“-l &amp;lt;load&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–load-average[=&amp;lt;load]”&lt;/p&gt;
&lt;p&gt;“-max-load[=&amp;lt;load&amp;gt;]”&lt;/p&gt;
&lt;p&gt;指定make运行命令的负载。&lt;/p&gt;
&lt;p&gt;“-n”&lt;/p&gt;
&lt;p&gt;“–just-print”&lt;/p&gt;
&lt;p&gt;“–dry-run”&lt;/p&gt;
&lt;p&gt;“–recon”&lt;/p&gt;
&lt;p&gt;仅输出执行过程中的命令序列，但并不执行。&lt;/p&gt;
&lt;p&gt;“-o &amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–old-file=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–assume-old=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。&lt;/file&gt;&lt;/p&gt;
&lt;p&gt;“-p”&lt;/p&gt;
&lt;p&gt;“–print-data-base”&lt;/p&gt;
&lt;p&gt;输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用”make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用”make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。&lt;/p&gt;
&lt;p&gt;“-q”&lt;/p&gt;
&lt;p&gt;“–question”&lt;/p&gt;
&lt;p&gt;不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。&lt;/p&gt;
&lt;p&gt;“-r”&lt;/p&gt;
&lt;p&gt;“–no-builtin-rules”&lt;/p&gt;
&lt;p&gt;禁止make使用任何隐含规则。&lt;/p&gt;
&lt;p&gt;“-R”&lt;/p&gt;
&lt;p&gt;“–no-builtin-variabes”&lt;/p&gt;
&lt;p&gt;禁止make使用任何作用于变量上的隐含规则。&lt;/p&gt;
&lt;p&gt;“-s”&lt;/p&gt;
&lt;p&gt;“–silent”&lt;/p&gt;
&lt;p&gt;“–quiet”&lt;/p&gt;
&lt;p&gt;在命令运行时不输出命令的输出。&lt;/p&gt;
&lt;p&gt;“-S”&lt;/p&gt;
&lt;p&gt;“–no-keep-going”&lt;/p&gt;
&lt;p&gt;“–stop”&lt;/p&gt;
&lt;p&gt;取消”-k”选项的作用。因为有些时候，make的选项是从环境变量”MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的”-k”选项失效。&lt;/p&gt;
&lt;p&gt;“-t”&lt;/p&gt;
&lt;p&gt;“–touch”&lt;/p&gt;
&lt;p&gt;相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。&lt;/p&gt;
&lt;p&gt;“-v”&lt;/p&gt;
&lt;p&gt;“–version”&lt;/p&gt;
&lt;p&gt;输出make程序的版本、版权等关于make的信息。&lt;/p&gt;
&lt;p&gt;“-w”&lt;/p&gt;
&lt;p&gt;“–print-directory”&lt;/p&gt;
&lt;p&gt;输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。&lt;/p&gt;
&lt;p&gt;“–no-print-directory”&lt;/p&gt;
&lt;p&gt;禁止”-w”选项。&lt;/p&gt;
&lt;p&gt;“-W &amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–what-if=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–new-file=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;“–assume-file=&amp;lt;file&amp;gt;”&lt;/p&gt;
&lt;p&gt;假定目标&amp;lt;file&amp;gt;需要更新，如果和”-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有”-n”那么就像运行UNIX的”touch”命令一样，使得&amp;lt;file&amp;gt;的修改时间为当前时间。&lt;/p&gt;
&lt;p&gt;“–warn-undefined-variables”&lt;/p&gt;
&lt;p&gt;只要make发现有未定义的变量，那么就输出警告信息。&lt;/p&gt;
&lt;h3 id=&quot;隐含规则&quot;&gt;&lt;a href=&quot;#隐含规则&quot; class=&quot;headerlink&quot; title=&quot;隐含规则&quot;&gt;&lt;/a&gt;隐含规则&lt;/h3&gt;&lt;p&gt;在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的”隐含的”，早先约定了的，不需要我们再写出来的规则。&lt;/p&gt;
&lt;p&gt;“隐含规则”也就是一种惯例，make会按照这种”惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。&lt;/p&gt;
&lt;p&gt;“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量”CFLAGS”可以控制编译时的编译器参数。&lt;/p&gt;
&lt;p&gt;我们还可以通过”模式规则”的方式写下自己的隐含规则。用”后缀规则”来定义隐含规则会有许多的限制。使用”模式规则”会更回得智能和清楚，但”后缀规则”可以用来保证我们Makefile的兼容性。我们了解了”隐含规则”，可以让其为我们更好的服务，也会让我们知道一些”约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候”隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。&lt;/p&gt;
&lt;h4 id=&quot;一、使用隐含规则&quot;&gt;&lt;a href=&quot;#一、使用隐含规则&quot; class=&quot;headerlink&quot; title=&quot;一、使用隐含规则&quot;&gt;&lt;/a&gt;一、使用隐含规则&lt;/h4&gt;&lt;p&gt;如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo : foo.o bar.o&amp;#10;&amp;#10;&amp;#9;cc &amp;#8211;o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的”隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。&lt;/p&gt;
&lt;p&gt;make 会在自己的”隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令”cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo.o : foo.c&amp;#10;&amp;#10;&amp;#9;cc &amp;#8211;c foo.c $(CFLAGS)&amp;#10;&amp;#10;bar.o : bar.c&amp;#10;&amp;#10;&amp;#9;cc &amp;#8211;c bar.c $(CFLAGS)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为，这已经是”约定”好了的事了，make和我们约定好了用C编译器”cc”生成[.o]文件的规则，这就是隐含规则。&lt;/p&gt;
&lt;p&gt;当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。&lt;/p&gt;
&lt;p&gt;还有，在make的”隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：&lt;/p&gt;
&lt;p&gt;foo.o : foo.p&lt;/p&gt;
&lt;p&gt;依赖文件”foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了”foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出”依赖规则”，而不写命令。&lt;/p&gt;
&lt;h4 id=&quot;二、隐含规则一览&quot;&gt;&lt;a href=&quot;#二、隐含规则一览&quot; class=&quot;headerlink&quot; title=&quot;二、隐含规则一览&quot;&gt;&lt;/a&gt;二、隐含规则一览&lt;/h4&gt;&lt;p&gt;这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数”-r”或”–no-builtin-rules”选项来取消所有的预设置的隐含规则。&lt;/p&gt;
&lt;p&gt;当然，即使是我们指定了”-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了”后缀规则”来定义的，所以，只要隐含规则中有”后缀列表 “（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。&lt;/p&gt;
&lt;p&gt;还是先来看一看常用的隐含规则吧。&lt;/p&gt;
&lt;p&gt;1、编译C程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.o”的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.c”，并且其生成命令是”$(CC) –c $(CPPFLAGS) $(CFLAGS)”&lt;/p&gt;
&lt;p&gt;2、编译C++程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.o” 的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.cc”或是”&amp;lt;n&amp;gt;.C”，并且其生成命令是”$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用”.cc”作为C++源文件的后缀，而不是”.C”）&lt;/p&gt;
&lt;p&gt;3、编译Pascal程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.o”的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.p”，并且其生成命令是”$(PC) –c $(PFLAGS)”。&lt;/p&gt;
&lt;p&gt;4、编译Fortran/Ratfor程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.o”的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.r”或”&amp;lt;n&amp;gt;.F”或”&amp;lt;n&amp;gt;.f”，并且其生成命令是:&lt;/p&gt;
&lt;p&gt;“.f” “$(FC) –c $(FFLAGS)”&lt;/p&gt;
&lt;p&gt;“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”&lt;/p&gt;
&lt;p&gt;“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”&lt;/p&gt;
&lt;p&gt;5、预处理Fortran/Ratfor程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.f”的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.r”或”&amp;lt;n&amp;gt;.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：&lt;/p&gt;
&lt;p&gt;“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”&lt;/p&gt;
&lt;p&gt;“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”&lt;/p&gt;
&lt;p&gt;6、编译Modula-2程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.sym” 的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.def”，并且其生成命令是：”$(M2C) $(M2FLAGS) $(DEFFLAGS)”。”&amp;lt;n.o&amp;gt;” 的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.mod”，并且其生成命令是：”$(M2C) $(M2FLAGS) $(MODFLAGS)”。&lt;/p&gt;
&lt;p&gt;7、汇编和汇编预处理的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.o” 的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.s”，默认使用编译品”as”，并且其生成命令是：”$(AS) $(ASFLAGS)”。”&amp;lt;n&amp;gt;.s” 的目标的依赖目标会自动推导为”&amp;lt;n&amp;gt;.S”，默认使用C预编译器”cpp”，并且其生成命令是：”$(AS) $(ASFLAGS)”。&lt;/p&gt;
&lt;p&gt;8、链接Object文件的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;” 目标依赖于”&amp;lt;n&amp;gt;.o”，通过运行C的编译器来运行链接程序生成（一般是”ld”），其生成命令是：”$(CC) $(LDFLAGS) &amp;lt;n&amp;gt;.o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：&lt;/p&gt;
&lt;p&gt;x : y.o z.o&lt;/p&gt;
&lt;p&gt;并且”x.c”、”y.c”和”z.c”都存在时，隐含规则将执行如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cc -c x.c -o x.o&amp;#10;&amp;#10;cc -c y.c -o y.o&amp;#10;&amp;#10;cc -c z.c -o z.o&amp;#10;&amp;#10;cc x.o y.o z.o -o x&amp;#10;&amp;#10;rm -f x.o&amp;#10;&amp;#10;rm -f y.o&amp;#10;&amp;#10;rm -f z.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。&lt;/p&gt;
&lt;p&gt;9、Yacc C程序时的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.c”的依赖文件被自动推导为”n.y”（Yacc生成的文件），其生成命令是：”$(YACC) $(YFALGS)”。（”Yacc”是一个语法分析器，关于其细节请查看相关资料）&lt;/p&gt;
&lt;p&gt;10、Lex C程序时的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.c”的依赖文件被自动推导为”n.l”（Lex生成的文件），其生成命令是：”$(LEX) $(LFALGS)”。（关于”Lex”的细节请查看相关资料）&lt;/p&gt;
&lt;p&gt;11、Lex Ratfor程序时的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.r”的依赖文件被自动推导为”n.l”（Lex生成的文件），其生成命令是：”$(LEX) $(LFALGS)”。&lt;/p&gt;
&lt;p&gt;12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。&lt;/p&gt;
&lt;p&gt;“&amp;lt;n&amp;gt;.ln” （lint生成的文件）的依赖文件被自动推导为”n.c”，其生成命令是：”$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于”&amp;lt;n&amp;gt;.y”和”&amp;lt;n&amp;gt;.l”也是同样的规则。&lt;/p&gt;
&lt;h4 id=&quot;三、隐含规则使用的变量&quot;&gt;&lt;a href=&quot;#三、隐含规则使用的变量&quot; class=&quot;headerlink&quot; title=&quot;三、隐含规则使用的变量&quot;&gt;&lt;/a&gt;三、隐含规则使用的变量&lt;/h4&gt;&lt;p&gt;在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的”-R”或”–no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。例如，第一条隐含规则–编译C程序的隐含规则的命令是”$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是”cc”，如果你把变量”$(CC)”重定义成”gcc”，把变量”$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以”gcc –c -g $(CPPFLAGS)”的样子来执行了。&lt;/p&gt;
&lt;p&gt;我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如”CC”；一种是参数相的关，如”CFLAGS”。下面是所有隐含规则中会用到的变量：&lt;/p&gt;
&lt;p&gt;1、关于命令的变量。&lt;/p&gt;
&lt;p&gt;AR&lt;/p&gt;
&lt;p&gt;函数库打包程序。默认命令是”ar”。&lt;/p&gt;
&lt;p&gt;AS&lt;/p&gt;
&lt;p&gt;汇编语言编译程序。默认命令是”as”。&lt;/p&gt;
&lt;p&gt;CC&lt;/p&gt;
&lt;p&gt;C语言编译程序。默认命令是”cc”。&lt;/p&gt;
&lt;p&gt;CXX&lt;/p&gt;
&lt;p&gt;C++语言编译程序。默认命令是”g++”。&lt;/p&gt;
&lt;p&gt;CO&lt;/p&gt;
&lt;p&gt;从 RCS文件中扩展文件程序。默认命令是”co”。&lt;/p&gt;
&lt;p&gt;CPP&lt;/p&gt;
&lt;p&gt;C程序的预处理器（输出是标准输出设备）。默认命令是”$(CC) –E”。&lt;/p&gt;
&lt;p&gt;FC&lt;/p&gt;
&lt;p&gt;Fortran 和 Ratfor 的编译器和预处理程序。默认命令是”f77”。&lt;/p&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;从SCCS文件中扩展文件的程序。默认命令是”get”。&lt;/p&gt;
&lt;p&gt;LEX&lt;/p&gt;
&lt;p&gt;Lex方法分析器程序（针对于C或Ratfor）。默认命令是”lex”。&lt;/p&gt;
&lt;p&gt;PC&lt;/p&gt;
&lt;p&gt;Pascal语言编译程序。默认命令是”pc”。&lt;/p&gt;
&lt;p&gt;YACC&lt;/p&gt;
&lt;p&gt;Yacc文法分析器（针对于C程序）。默认命令是”yacc”。&lt;/p&gt;
&lt;p&gt;YACCR&lt;/p&gt;
&lt;p&gt;Yacc文法分析器（针对于Ratfor程序）。默认命令是”yacc –r”。&lt;/p&gt;
&lt;p&gt;MAKEINFO&lt;/p&gt;
&lt;p&gt;转换Texinfo源文件（.texi）到Info文件程序。默认命令是”makeinfo”。&lt;/p&gt;
&lt;p&gt;TEX&lt;/p&gt;
&lt;p&gt;从TeX源文件创建TeX DVI文件的程序。默认命令是”tex”。&lt;/p&gt;
&lt;p&gt;TEXI2DVI&lt;/p&gt;
&lt;p&gt;从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是”texi2dvi”。&lt;/p&gt;
&lt;p&gt;WEAVE&lt;/p&gt;
&lt;p&gt;转换Web到TeX的程序。默认命令是”weave”。&lt;/p&gt;
&lt;p&gt;CWEAVE&lt;/p&gt;
&lt;p&gt;转换C Web 到 TeX的程序。默认命令是”cweave”。&lt;/p&gt;
&lt;p&gt;TANGLE&lt;/p&gt;
&lt;p&gt;转换Web到Pascal语言的程序。默认命令是”tangle”。&lt;/p&gt;
&lt;p&gt;CTANGLE&lt;/p&gt;
&lt;p&gt;转换C Web 到 C。默认命令是”ctangle”。&lt;/p&gt;
&lt;p&gt;RM&lt;/p&gt;
&lt;p&gt;删除文件命令。默认命令是”rm –f”。&lt;/p&gt;
&lt;p&gt;2、关于命令参数的变量&lt;/p&gt;
&lt;p&gt;下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。&lt;/p&gt;
&lt;p&gt;ARFLAGS&lt;/p&gt;
&lt;p&gt;函数库打包程序AR命令的参数。默认值是”rv”。&lt;/p&gt;
&lt;p&gt;ASFLAGS&lt;/p&gt;
&lt;p&gt;汇编语言编译器参数。（当明显地调用”.s”或”.S”文件时）。&lt;/p&gt;
&lt;p&gt;CFLAGS&lt;/p&gt;
&lt;p&gt;C语言编译器参数。&lt;/p&gt;
&lt;p&gt;CXXFLAGS&lt;/p&gt;
&lt;p&gt;C++语言编译器参数。&lt;/p&gt;
&lt;p&gt;COFLAGS&lt;/p&gt;
&lt;p&gt;RCS命令参数。&lt;/p&gt;
&lt;p&gt;CPPFLAGS&lt;/p&gt;
&lt;p&gt;C预处理器参数。（ C 和 Fortran 编译器也会用到）。&lt;/p&gt;
&lt;p&gt;FFLAGS&lt;/p&gt;
&lt;p&gt;Fortran语言编译器参数。&lt;/p&gt;
&lt;p&gt;GFLAGS&lt;/p&gt;
&lt;p&gt;SCCS “get”程序参数。&lt;/p&gt;
&lt;p&gt;LDFLAGS&lt;/p&gt;
&lt;p&gt;链接器参数。（如：”ld”）&lt;/p&gt;
&lt;p&gt;LFLAGS&lt;/p&gt;
&lt;p&gt;Lex文法分析器参数。&lt;/p&gt;
&lt;p&gt;PFLAGS&lt;/p&gt;
&lt;p&gt;Pascal语言编译器参数。&lt;/p&gt;
&lt;p&gt;RFLAGS&lt;/p&gt;
&lt;p&gt;Ratfor 程序的Fortran 编译器参数。&lt;/p&gt;
&lt;p&gt;YFLAGS&lt;/p&gt;
&lt;p&gt;Yacc文法分析器参数。&lt;/p&gt;
&lt;h4 id=&quot;四、隐含规则链&quot;&gt;&lt;a href=&quot;#四、隐含规则链&quot; class=&quot;headerlink&quot; title=&quot;四、隐含规则链&quot;&gt;&lt;/a&gt;四、隐含规则链&lt;/h4&gt;&lt;p&gt;有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做”隐含规则链”。&lt;/p&gt;
&lt;p&gt;在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。&lt;/p&gt;
&lt;p&gt;我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？&lt;/p&gt;
&lt;p&gt;在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以”rm -f”删除。&lt;/p&gt;
&lt;p&gt;通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标”.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）&lt;/p&gt;
&lt;p&gt;你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标”.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标”.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。&lt;/p&gt;
&lt;p&gt;在”隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。&lt;/p&gt;
&lt;p&gt;Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件”foo.c”生成目标程序”foo”，按道理，make会编译生成中间文件”foo.o”，然后链接成”foo”，但在实际情况下，这一动作可以被一条”cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。&lt;/p&gt;
&lt;h4 id=&quot;五、定义模式规则&quot;&gt;&lt;a href=&quot;#五、定义模式规则&quot; class=&quot;headerlink&quot; title=&quot;五、定义模式规则&quot;&gt;&lt;/a&gt;五、定义模式规则&lt;/h4&gt;&lt;p&gt;你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。&lt;/p&gt;
&lt;p&gt;有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。&lt;/p&gt;
&lt;p&gt;1、模式规则介绍&lt;/p&gt;
&lt;p&gt;模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为 5）。&lt;/p&gt;
&lt;p&gt;如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：&lt;/p&gt;
&lt;p&gt;%.o : %.c ; &amp;lt;command ……&amp;gt;&lt;/p&gt;
&lt;p&gt;其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。&lt;/p&gt;
&lt;p&gt;一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。&lt;/p&gt;
&lt;p&gt;2、模式规则示例&lt;/p&gt;
&lt;p&gt;下面这个例子表示了，把所有的[.c]文件都编译成[.o]文件。&lt;/p&gt;
&lt;p&gt;%.o : %.c&lt;/p&gt;
&lt;p&gt;$(CC) -c $(CFLAGS) $(CPPFLAGS) $&amp;lt; -o $@&lt;/p&gt;
&lt;p&gt;其中，”$@”表示所有的目标的挨个值，”$&amp;lt;”表示了所有依赖目标的挨个值。这些奇怪的变量我们叫”自动化变量”，后面会详细讲述。&lt;/p&gt;
&lt;p&gt;下面的这个例子中有两个目标是模式的：&lt;/p&gt;
&lt;p&gt;%.tab.c %.tab.h: %.y&lt;/p&gt;
&lt;p&gt;bison -d $&amp;lt;&lt;/p&gt;
&lt;p&gt;这条规则告诉make把所有的[.y]文件都以”bison -d &amp;lt;n&amp;gt;.y”执行，然后生成”&amp;lt;n&amp;gt;.tab.c”和”&amp;lt;n&amp;gt;.tab.h”文件。（其中，”&amp;lt;n&amp;gt;” 表示一个任意字符串）。如果我们的执行程序”foo”依赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o” 由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）&lt;/p&gt;
&lt;p&gt;3、自动化变量&lt;/p&gt;
&lt;p&gt;在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。&lt;/p&gt;
&lt;p&gt;自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。&lt;/p&gt;
&lt;p&gt;下面是所有的自动化变量及其说明：&lt;/p&gt;
&lt;p&gt;$@表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。&lt;/p&gt;
&lt;p&gt;$%仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。&lt;/p&gt;
&lt;p&gt;$&amp;lt;依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&amp;lt;”将是符&lt;br&gt;合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;/p&gt;
&lt;p&gt;$?所有比目标新的依赖目标的集合。以空格分隔。&lt;/p&gt;
&lt;p&gt;$^所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。&lt;/p&gt;
&lt;p&gt;$+这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;/p&gt;
&lt;p&gt;$&lt;em&gt;这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，”$&lt;/em&gt;“的值就是”dir /a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么”$&lt;em&gt;“也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么”$&lt;/em&gt;“就是除了后缀的那一部分。例如：如果目标是”foo.c”，因为”.c”是make所能识别的后缀名，所以，”$&lt;em&gt;“的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用”$&lt;/em&gt;“，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么”$*”就是空值。&lt;/p&gt;
&lt;p&gt;当你希望只对更新过的依赖文件进行操作时，”$?”在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：&lt;/p&gt;
&lt;p&gt;lib : foo.o bar.o lose.o win.o&lt;/p&gt;
&lt;p&gt;ar r lib $?&lt;/p&gt;
&lt;p&gt;在上述所列出来的自动量变量中。四个变量（$@、$&amp;lt;、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。&lt;/p&gt;
&lt;p&gt;下面是对于上面的七个变量分别加上”D”或是”F”的含义：&lt;/p&gt;
&lt;p&gt;$(@D)表示”$@”的目录部分（不以斜杠作为结尾），如果”$@”值是”dir/foo.o”，那么”$(@D)”就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。&lt;/p&gt;
&lt;p&gt;$(@F)表示”$@”的文件部分，如果”$@”值是”dir/foo.o”，那么”$(@F)”就是”foo.o”，”$(@F)”相当于函数”$(notdir $@)”。&lt;/p&gt;
&lt;p&gt;“$(*D)””$(*F)”和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，”$(*D)”返回”dir”，而”$(*F)”返回”foo”&lt;/p&gt;
&lt;p&gt;“$(%D)””$(%F)”分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。&lt;/p&gt;
&lt;p&gt;“$(&amp;lt;D)””$(&amp;lt;F)”分别表示依赖文件的目录部分和文件部分。&lt;/p&gt;
&lt;p&gt;“$(^D)””$(^F)”分别表示所有依赖文件的目录部分和文件部分。（无相同的）&lt;/p&gt;
&lt;p&gt;“$(+D)””$(+F)”分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）&lt;/p&gt;
&lt;p&gt;“$(?D)””$(?F)”分别表示被更新的依赖文件的目录部分和文件部分。&lt;/p&gt;
&lt;p&gt;最后想提醒一下的是，对于”$&amp;lt;”，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$(&amp;lt; )”就要比”$&amp;lt;”要好一些。&lt;/p&gt;
&lt;p&gt;还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。&lt;/p&gt;
&lt;p&gt;4、模式的匹配&lt;/p&gt;
&lt;p&gt;一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。&lt;/p&gt;
&lt;p&gt;当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）&lt;/p&gt;
&lt;p&gt;5、重载内建隐含规则&lt;/p&gt;
&lt;p&gt;你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;%.o : %.c&amp;#10;&amp;#10;$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以取消内建的隐含规则，只要不在后面写命令就行。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;%.o : %.s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。&lt;/p&gt;
&lt;h4 id=&quot;六、老式风格的”后缀规则”&quot;&gt;&lt;a href=&quot;#六、老式风格的”后缀规则”&quot; class=&quot;headerlink&quot; title=&quot;六、老式风格的”后缀规则”&quot;&gt;&lt;/a&gt;六、老式风格的”后缀规则”&lt;/h4&gt;&lt;p&gt;后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。&lt;/p&gt;
&lt;p&gt;双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。&lt;/p&gt;
&lt;p&gt;后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。如下示例：&lt;/p&gt;
&lt;p&gt;.c.o:&lt;/p&gt;
&lt;p&gt;$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;&lt;/p&gt;
&lt;p&gt;后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：&lt;/p&gt;
&lt;p&gt;.c.o: foo.h&lt;/p&gt;
&lt;p&gt;$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;&lt;/p&gt;
&lt;p&gt;这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：&lt;/p&gt;
&lt;p&gt;%.o: %.c foo.h&lt;/p&gt;
&lt;p&gt;$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;&lt;/p&gt;
&lt;p&gt;后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。&lt;/p&gt;
&lt;p&gt;而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除，如：&lt;/p&gt;
&lt;p&gt;.SUFFIXES: .hack .win&lt;/p&gt;
&lt;p&gt;把后缀.hack和.win加入后缀列表中的末尾。&lt;/p&gt;
&lt;p&gt;.SUFFIXES: # 删除默认的后缀&lt;/p&gt;
&lt;p&gt;.SUFFIXES: .c .o .h # 定义自己的后缀&lt;/p&gt;
&lt;p&gt;先清除默认后缀，后定义自己的后缀列表。&lt;/p&gt;
&lt;p&gt;make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。&lt;/p&gt;
&lt;h4 id=&quot;七、隐含规则搜索算法&quot;&gt;&lt;a href=&quot;#七、隐含规则搜索算法&quot; class=&quot;headerlink&quot; title=&quot;七、隐含规则搜索算法&quot;&gt;&lt;/a&gt;七、隐含规则搜索算法&lt;/h4&gt;&lt;p&gt;比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。&lt;/p&gt;
&lt;p&gt;1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）&lt;/p&gt;
&lt;p&gt;2、创建所有匹配于T或是N的模式规则列表。&lt;/p&gt;
&lt;p&gt;3、如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。&lt;/p&gt;
&lt;p&gt;4、移除列表中没有命令的规则。&lt;/p&gt;
&lt;p&gt;5、对于第一个在列表中的模式规则：&lt;/p&gt;
&lt;p&gt;1）推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。&lt;/p&gt;
&lt;p&gt;2）计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。&lt;/p&gt;
&lt;p&gt;3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）&lt;/p&gt;
&lt;p&gt;4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。&lt;/p&gt;
&lt;p&gt;6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：&lt;/p&gt;
&lt;p&gt;1）如果规则是终止规则，那就忽略它，继续下一条模式规则。&lt;/p&gt;
&lt;p&gt;2）计算依赖文件。（同第5步）&lt;/p&gt;
&lt;p&gt;3）测试所有的依赖文件是否存在或是理当存在。&lt;/p&gt;
&lt;p&gt;4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。&lt;/p&gt;
&lt;p&gt;5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。&lt;/p&gt;
&lt;p&gt;7、如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。&lt;/p&gt;
&lt;p&gt;一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。&lt;/p&gt;
&lt;h3 id=&quot;使用make更新函数库文件&quot;&gt;&lt;a href=&quot;#使用make更新函数库文件&quot; class=&quot;headerlink&quot; title=&quot;使用make更新函数库文件&quot;&gt;&lt;/a&gt;使用make更新函数库文件&lt;/h3&gt;&lt;p&gt;函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。&lt;/p&gt;
&lt;h4 id=&quot;一、函数库文件的成员&quot;&gt;&lt;a href=&quot;#一、函数库文件的成员&quot; class=&quot;headerlink&quot; title=&quot;一、函数库文件的成员&quot;&gt;&lt;/a&gt;一、函数库文件的成员&lt;/h4&gt;&lt;p&gt;一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：&lt;/p&gt;
&lt;p&gt;archive(member)&lt;/p&gt;
&lt;p&gt;这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：&lt;/p&gt;
&lt;p&gt;foolib(hack.o) : hack.o&lt;/p&gt;
&lt;p&gt;ar cr foolib hack.o&lt;/p&gt;
&lt;p&gt;如果要指定多个member，那就以空格分开，如：&lt;/p&gt;
&lt;p&gt;foolib(hack.o kludge.o)&lt;/p&gt;
&lt;p&gt;其等价于：&lt;/p&gt;
&lt;p&gt;foolib(hack.o) foolib(kludge.o)&lt;/p&gt;
&lt;p&gt;你还可以使用Shell的文件通配符来定义，如：&lt;/p&gt;
&lt;p&gt;foolib(*.o)&lt;/p&gt;
&lt;h4 id=&quot;二、函数库成员的隐含规则&quot;&gt;&lt;a href=&quot;#二、函数库成员的隐含规则&quot; class=&quot;headerlink&quot; title=&quot;二、函数库成员的隐含规则&quot;&gt;&lt;/a&gt;二、函数库成员的隐含规则&lt;/h4&gt;&lt;p&gt;当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cc -c bar.c -o bar.o&amp;#10;&amp;#10;ar r foo.a bar.o&amp;#10;&amp;#10;rm -f bar.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。&lt;/p&gt;
&lt;h4 id=&quot;三、函数库文件的后缀规则&quot;&gt;&lt;a href=&quot;#三、函数库文件的后缀规则&quot; class=&quot;headerlink&quot; title=&quot;三、函数库文件的后缀规则&quot;&gt;&lt;/a&gt;三、函数库文件的后缀规则&lt;/h4&gt;&lt;p&gt;你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.c.a:&amp;#10;&amp;#10;$(CC) $(CFLAGS) $(CPPFLAGS) -c $&amp;#60; -o $*.o&amp;#10;&amp;#10;$(AR) r $@ $*.o&amp;#10;&amp;#10;$(RM) $*.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其等效于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(%.o) : %.c&amp;#10;&amp;#10;$(CC) $(CFLAGS) $(CPPFLAGS) -c $&amp;#60; -o $*.o&amp;#10;&amp;#10;$(AR) r $@ $*.o&amp;#10;&amp;#10;$(RM) $*.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;四、注意事项&quot;&gt;&lt;a href=&quot;#四、注意事项&quot; class=&quot;headerlink&quot; title=&quot;四、注意事项&quot;&gt;&lt;/a&gt;四、注意事项&lt;/h4&gt;&lt;p&gt;在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。&lt;/p&gt;
&lt;p&gt;但就目前而言，你还是应该不要尽量不要使用”-j”参数。&lt;/p&gt;
&lt;h3 id=&quot;后序&quot;&gt;&lt;a href=&quot;#后序&quot; class=&quot;headerlink&quot; title=&quot;后序&quot;&gt;&lt;/a&gt;后序&lt;/h3&gt;&lt;p&gt;终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测”函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）”杀伤力”。&lt;/p&gt;
&lt;p&gt;对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp&amp;hellip;&amp;hellip;等等，等等，来完成诸如”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N”奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的”@@@N、###N”等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的”扩展C”语言（即在C语言中用”EXEC SQL”的样子执行SQL语句，在用 cc/gcc编译之前，需要使用”扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果你在使用make时有一些更为绝妙的方法，请记得告诉我啊。&lt;/p&gt;
&lt;p&gt;回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入”!make”时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。&lt;/p&gt;
&lt;p&gt;现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的 Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。&lt;/p&gt;
&lt;p&gt;最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命–网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在”技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是：haoel@hotmail.com（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾邮件导致我拒收这个邮箱的所有来信）我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！&lt;/p&gt;
&lt;p&gt;最最后，我还想介绍一下make程序的设计开发者。&lt;/p&gt;
&lt;p&gt;首当其冲的是： Richard Stallman开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：&lt;a href=&quot;http://www.stallman.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.stallman.org/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;第二位是：Roland McGrath个人主页是：&lt;a href=&quot;http://www.frob.com/~roland/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.frob.com/~roland/&lt;/a&gt; ，下面是他的一些事迹：&lt;/p&gt;
&lt;p&gt;1） 合作编写了并维护GNU make。&lt;/p&gt;
&lt;p&gt;2） 和Thomas Bushnell一同编写了GNU Hurd。&lt;/p&gt;
&lt;p&gt;3） 编写并维护着GNU C library。&lt;/p&gt;
&lt;p&gt;4） 合作编写并维护着部分的GNU Emacs。&lt;/p&gt;
&lt;p&gt;在此，向这两位开源项目的斗士致以最真切的敬意。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Make, Android" scheme="http://gonggaofeng.me/tags/Make-Android/"/>
    
  </entry>
  
  <entry>
    <title>Java资源大全中文版</title>
    <link href="http://gonggaofeng.me/2016/03/29/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>http://gonggaofeng.me/2016/03/29/Java资源大全中文版/</id>
    <published>2016-03-28T16:06:09.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/akullpp/awesome-java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;awesome-java&lt;/a&gt; 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 &lt;a href=&quot;http://www.importnew.com/14429.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImportNew&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;我们要做什么？&quot;&gt;&lt;a href=&quot;#我们要做什么？&quot; class=&quot;headerlink&quot; title=&quot;我们要做什么？&quot;&gt;&lt;/a&gt;我们要做什么？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。&lt;/li&gt;
&lt;li&gt;整理后的内容，将收录在&lt;a href=&quot;http://hao.jobbole.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;伯乐在线资源频道&lt;/a&gt;。可参考已整理的内容：&lt;ul&gt;
&lt;li&gt;《&lt;a href=&quot;http://hao.jobbole.com/pgcli-postgresql/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PgCli：支持自动补全和语法高亮的 PostgreSQL 工具&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;http://hao.jobbole.com/wireshark/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wireshark：开源的网络数据包分析软件&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;http://hao.jobbole.com/tcpdump/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tcpdump：运行在命令行下的嗅探工具&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;如何参与本项目？&quot;&gt;&lt;a href=&quot;#如何参与本项目？&quot; class=&quot;headerlink&quot; title=&quot;如何参与本项目？&quot;&gt;&lt;/a&gt;如何参与本项目？&lt;/h3&gt;&lt;p&gt;从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。&lt;/p&gt;
&lt;p&gt;不过加入前，有几个小要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英文还不错，能读懂英文并用自己的话复述；&lt;/li&gt;
&lt;li&gt;在用 Java；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如有兴趣，请加 QQ：50872495。加 Q 时请注明「Java大全」&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;本项目的参与者&quot;&gt;&lt;a href=&quot;#本项目的参与者&quot; class=&quot;headerlink&quot; title=&quot;本项目的参与者&quot;&gt;&lt;/a&gt;本项目的参与者&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;维护者：&lt;a href=&quot;https://github.com/tangyouhua&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tangyouhua&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;贡献者：&lt;a href=&quot;https://github.com/tangyouhua&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tangyouhua&lt;/a&gt;、&lt;a href=&quot;https://github.com/kingzone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kingzone&lt;/a&gt;、&lt;a href=&quot;https://github.com/llhua2329&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;llhua2329&lt;/a&gt;、&lt;a href=&quot;https://github.com/BadCoderChou&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BadCoderChou&lt;/a&gt;、You&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：名单不分排名，不定期补充更新&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#awesome-java-cn&quot;&gt;Java资源大全中文版&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ancients&quot;&gt;古董级工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#build&quot;&gt;构建工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#bytecode-manipulation&quot;&gt;字节码操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cluster-management&quot;&gt;集群管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code-analysis&quot;&gt;代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#compiler-compiler&quot;&gt;编译器生成工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#configuration&quot;&gt;外部配置工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#constraint-satisfaction-problem-solver&quot;&gt;约束满足问题求解程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#continuous-integration&quot;&gt;持续集成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#csv&quot;&gt;CSV解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#data-structures&quot;&gt;数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#database&quot;&gt;数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#date-and-time&quot;&gt;时间日期工具库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dependency-injection&quot;&gt;依赖注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#development&quot;&gt;开发流程增强工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#distributed-applications&quot;&gt;分布式应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#distributed-databases&quot;&gt;分布式数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#distribution&quot;&gt;发布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#document-processing&quot;&gt;文档处理工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#functional-programming&quot;&gt;函数式编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#game-development&quot;&gt;游戏开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#gui&quot;&gt;GUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#high-performance&quot;&gt;高性能计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ide&quot;&gt;IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#imagery&quot;&gt;图像处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#json&quot;&gt;JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-and-jdk&quot;&gt;JVM与JDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#languages&quot;&gt;基于JVM的语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#logging&quot;&gt;日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#machine-learning&quot;&gt;机器学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#messaging&quot;&gt;消息传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#miscellaneous&quot;&gt;杂项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#monitoring&quot;&gt;应用监控工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#native&quot;&gt;原生开发库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#natural-language-processing&quot;&gt;自然语言处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#networking&quot;&gt;网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#orm&quot;&gt;ORM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pdf&quot;&gt;PDF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#performance-analysis&quot;&gt;性能分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#reactive-libraries&quot;&gt;响应式开发库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#rest-frameworks&quot;&gt;REST框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#science&quot;&gt;科学计算与分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#search&quot;&gt;搜索引擎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#security&quot;&gt;安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#serialization&quot;&gt;序列化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#server&quot;&gt;应用服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#template-engine&quot;&gt;模板引擎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#testing&quot;&gt;测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#utility&quot;&gt;通用工具库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#web-crawling&quot;&gt;网络爬虫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#web-frameworks&quot;&gt;Web框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#resources&quot;&gt;资源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#communities&quot;&gt;社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#influential-books&quot;&gt;有影响力的书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#podcasts&quot;&gt;播客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#weibo-weixin&quot;&gt;微博、微信公众号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#twitter&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#websites&quot;&gt;知名网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;blogs&quot;&gt;博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ancients&quot;&gt;古董级工具&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ant.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Ant&lt;/a&gt;：基于XML的构建管理工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cglib&lt;/a&gt;：字节码生成库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://glassfish.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GlassFish&lt;/a&gt;：应用服务器，由Oracle赞助支持的Java EE参考实现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hudson-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hudson&lt;/a&gt; ：持续集成服务器，目前仍在活跃开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://javaserverfaces.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaServer Faces&lt;/a&gt;：Mojarra是JSF标准的一个开源实现，由Oracle开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jsp.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaServer Pages&lt;/a&gt;：支持自定义标签库的网站通用模板库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.liquibase.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Liquibase&lt;/a&gt;：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;build&quot;&gt;构建工具&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;构建及应用依赖关系处理工具。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://maven.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Maven&lt;/a&gt; ：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bazel.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bazel&lt;/a&gt;：来自Google的构建工具，可以快速、可靠地构建代码。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gradle.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gradle&lt;/a&gt;：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;bytecode-manipulation&quot;&gt;字节码操作&lt;/h3&gt;&lt;br&gt;&lt;em&gt;编程方式操作字节码的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://asm.ow2.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ASM&lt;/a&gt;：通用底层字节码操作和分析开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bytebuddy.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Byte Buddy&lt;/a&gt;：使用流式API进一步简化字节码生成。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://byteman.jboss.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Byteman&lt;/a&gt;：在运行时通过DSL（规则）操作字节码进行测试和故障排除。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jboss-javassist.github.io/javassist&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javassist&lt;/a&gt;：一个简化字节码编辑尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;cluster-management&quot;&gt;集群管理&lt;/h3&gt;&lt;br&gt;&lt;em&gt;在集群内动态管理应用程序的框架。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aurora.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Aurora&lt;/a&gt;：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://getsingularity.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Singularity&lt;/a&gt;：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;code-analysis&quot;&gt;代码分析&lt;/h3&gt;&lt;br&gt;&lt;em&gt;测量代码指标和质量工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/checkstyle/checkstyle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Checkstyle&lt;/a&gt;：代码编写规范和标准静态分析工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/error-prone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Error Prone&lt;/a&gt;：将常见编程错误作为运行时错误报告。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://findbugs.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FindBugs&lt;/a&gt;：通过字节码静态分析查找隐藏bug。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jqassistant.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jQAssistant&lt;/a&gt;：使用基于Neo4J查询语言进行代码静态分析。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pmd/pmd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PMD&lt;/a&gt;：对源代码分析查找不良的编程习惯。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.sonarqube.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SonarQube&lt;/a&gt;：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;compiler-compiler&quot;&gt;编译器生成工具&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来创建解析器、解释器或编译器的框架。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.antlr.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ANTLR&lt;/a&gt;：复杂的全功能自顶向下解析框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://javacc.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaCC&lt;/a&gt;：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;configuration&quot;&gt;外部配置工具&lt;/h3&gt;&lt;br&gt;&lt;em&gt;支持外部配置的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/typesafehub/config&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;config&lt;/a&gt;：针对JVM语言的配置库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lviggiano/owner&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;owner&lt;/a&gt;：减少冗余配置属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;constraint-satisfaction-problem-solver&quot;&gt;约束满足问题求解程序&lt;/h3&gt;&lt;br&gt;&lt;em&gt;帮助解决约束满足问题的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://choco-solver.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Choco&lt;/a&gt;：可直接使用的约束满足问题求解程序，使用了约束规划技术。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/radsz/jacop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JaCoP&lt;/a&gt;：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.optaplanner.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OptaPlanner&lt;/a&gt;：企业规划与资源调度优化求解程序。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.sat4j.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sat4J&lt;/a&gt;：逻辑代数与优化问题最先进的求解程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;continuous-integration&quot;&gt;持续集成&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/software/bamboo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bamboo&lt;/a&gt;：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://circleci.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CircleCI&lt;/a&gt;：提供托管服务，可以免费试用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codeship.io/features&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Codeship&lt;/a&gt;：提供托管服务，提供有限的免费模式。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://fabric8.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fabric8&lt;/a&gt;：容器集成平台。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.thoughtworks.com/products/go-continuous-delivery&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go&lt;/a&gt;：ThoughtWork开源解决方案。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins&lt;/a&gt;：支持基于服务器的部署服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jetbrains.com/teamcity/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TeamCity&lt;/a&gt;：JetBrain的持续集成解决方案，有免费版。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Travis&lt;/a&gt;：通常用作开源项目的托管服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;csv&quot;&gt;CSV解析&lt;/h3&gt;&lt;br&gt;&lt;em&gt;简化CSV数据读写的框架与开发库&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/uniVocity/univocity-parsers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;uniVocity-parsers&lt;/a&gt;：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;database&quot;&gt;数据库&lt;/h3&gt;&lt;br&gt;&lt;em&gt;简化数据库交互的相关工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://phoenix.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Phoenix&lt;/a&gt;：HBase针对低延时应用程序的高性能关系数据库层。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crate.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crate&lt;/a&gt;：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://flywaydb.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flyway&lt;/a&gt;：简单的数据库迁移工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://h2database.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;H2&lt;/a&gt;：小型SQL数据库，以可以作为内存数据库使用著称。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/brettwooldridge/HikariCP&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HikariCP&lt;/a&gt;：高性能JDBC连接工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jdbi.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JDBI&lt;/a&gt;：便捷的JDBC抽象。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jooq.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jOOQ&lt;/a&gt;：为SQL schema生成typesafe代码。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mapdb.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MapDB&lt;/a&gt;：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/presto&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Presto&lt;/a&gt;：针对大数据的分布式SQL查询引擎。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.querydsl.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Querydsl&lt;/a&gt;：Typesafe统一查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;data-structures&quot;&gt;数据结构&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://parquet.incubator.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Parquet&lt;/a&gt;：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/protobuf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Protobuf&lt;/a&gt;：Google数据交换格式。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/real-logic/simple-binary-encoding&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SBE&lt;/a&gt;：简单二进制编码，是最快速的消息格式之一。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/wire&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wire&lt;/a&gt;：整洁轻量级协议缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;date-and-time&quot;&gt;时间日期工具库&lt;/h3&gt;&lt;br&gt;&lt;em&gt;处理时间和日期的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Joda-Time&lt;/a&gt;：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MenoData/Time4J&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Time4J&lt;/a&gt;：高级时间和日期库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;dependency-injection&quot;&gt;依赖注入&lt;/h3&gt;&lt;br&gt;&lt;em&gt;帮助实现&lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_control&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;依赖翻转&lt;/a&gt;范式的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://deltaspike.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache DeltaSpike&lt;/a&gt;：CDI扩展框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://google.github.io/dagger/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dagger2&lt;/a&gt;：编译时注入框架，不需要使用反射。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/guice&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Guice&lt;/a&gt;：可以匹敌Dagger的轻量级注入框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hk2.java.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HK2&lt;/a&gt;：轻量级动态依赖注入框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;development&quot;&gt;开发流程增强工具&lt;/h3&gt;&lt;br&gt;&lt;em&gt;从最基本的层面增强开发流程。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sviperll/adt4j&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ADT4J&lt;/a&gt;：针对代数数据类型的JSR-269代码生成器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://eclipse.org/aspectj/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AspectJ&lt;/a&gt;：面向切面编程（AOP）的无缝扩展。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/auto&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Auto&lt;/a&gt;：源代码生成器集合。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dcevm.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DCEVM&lt;/a&gt;：通过修改JVM在运行时支持对已加载的类进行无限次重定义。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/HotswapProjects/HotswapAgent&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HotswapAgent&lt;/a&gt;：支持无限次重定义运行时类与资源。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://immutables.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Immutables&lt;/a&gt;：类似Scala的条件类。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jhipster/generator-jhipster&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JHipster&lt;/a&gt;：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zeroturnaround.com/software/jrebel/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JRebel&lt;/a&gt;：无需重新部署，可以即时重新加载代码与配置的商业软件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://projectlombok.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lombok&lt;/a&gt;：减少冗余的代码生成器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-loaded&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Loaded&lt;/a&gt;：类重载代理。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vertx.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vert.x&lt;/a&gt;：多语言事件驱动应用框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;distributed-applications&quot;&gt;分布式应用&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来编写分布式容错应用的开发库和框架。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://akka.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Akka&lt;/a&gt;：用来编写分布式容错并发事件驱动应用程序的工具和运行时。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://storm.incubator.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Storm&lt;/a&gt;：实时计算系统。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zookeeper.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache ZooKeeper&lt;/a&gt;：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hazelcast.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hazelcast&lt;/a&gt;：高可扩展内存数据网格。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hystrix&lt;/a&gt;：提供延迟和容错。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jgroups.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JGroups&lt;/a&gt;：提供可靠的消息传递和集群创建的工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://orbit.bioware.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Orbit&lt;/a&gt;：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.paralleluniverse.co/quasar/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Quasar&lt;/a&gt;：为JVM提供轻量级线程和角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;distributed-databases&quot;&gt;分布式数据库&lt;/h3&gt;&lt;br&gt;&lt;em&gt;对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://cassandra.apache.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Cassandra&lt;/a&gt;：列式数据库，可用性高且没有单点故障。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hbase.apache.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache HBase&lt;/a&gt;：针对大数据的Hadoop数据库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://druid.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Druid&lt;/a&gt;：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://infinispan.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Infinispan&lt;/a&gt;：针对缓存的高并发键值对数据存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;distribution&quot;&gt;发布&lt;/h3&gt;&lt;br&gt;&lt;em&gt;以本机格式发布应用程序的工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bintray.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bintray&lt;/a&gt;：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://search.maven.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Central Repository&lt;/a&gt;：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central Repository，也可以在所有其他构建工具中使用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://izpack.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IzPack&lt;/a&gt;：为跨平台部署建立创作工具（Authoring Tool）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jitpack.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JitPack&lt;/a&gt;：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://launch4j.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Launch4j&lt;/a&gt;：将JAR包装为轻量级本机Windows可执行程序。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.sonatype.com/nexus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nexus&lt;/a&gt;：支持代理和缓存功能的二进制管理工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/libgdx/packr/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;packr&lt;/a&gt;：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;document-processing&quot;&gt;文档处理工具&lt;/h3&gt;&lt;br&gt;&lt;em&gt;处理Office文档的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://poi.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache POI&lt;/a&gt;：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://documents4j.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documents4j&lt;/a&gt;：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jopendocument.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jOpenDocument&lt;/a&gt;：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;functional-programming&quot;&gt;函数式编程&lt;/h3&gt;&lt;br&gt;&lt;em&gt;函数式编程支持库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/aol/cyclops&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cyclops&lt;/a&gt;：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/atlassian/fugue&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fugue&lt;/a&gt;：Guava的函数式编程扩展。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.functionaljava.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Functional Java&lt;/a&gt;：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javaslang.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javaslang&lt;/a&gt;：一个函数式组件库，提供持久化数据类型和函数式控制结构。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jOOQ/jOOL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jOOλ&lt;/a&gt;：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;game-development&quot;&gt;游戏开发&lt;/h3&gt;&lt;br&gt;&lt;em&gt;游戏开发框架。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jmonkeyengine.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jMonkeyEngine&lt;/a&gt;：现代3D游戏开发引擎。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://libgdx.badlogicgames.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libGDX&lt;/a&gt;：全面的跨平台高级框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwjgl.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LWJGL&lt;/a&gt;：对OpenGL/CL/AL等技术进行抽象的健壮框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;gui&quot;&gt;GUI&lt;/h3&gt;&lt;br&gt;&lt;em&gt;现代图形化用户界面开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaFX&lt;/a&gt;：Swing的后继者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/javafxscenebuilder-info-2157684.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Scene Builder&lt;/a&gt;：开发JavaFX应用的可视化布局工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;high-performance&quot;&gt;高性能计算&lt;/h3&gt;&lt;br&gt;&lt;em&gt;涵盖了从集合到特定开发库的高性能计算相关工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/real-logic/Agrona&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Agrona&lt;/a&gt;：高性能应用中常见的数据结构和工具方法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lmax-exchange.github.io/disruptor/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Disruptor&lt;/a&gt;：线程间消息传递开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://fastutil.di.unimi.it/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fastutil&lt;/a&gt;：快速紧凑的特定类型集合（Collection）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GS Collections&lt;/a&gt;：受Smalltalk启发的集合框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://labs.carrotsearch.com/hppc.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HPPC&lt;/a&gt;：基础类型集合。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javolution.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javolution&lt;/a&gt;：实时和嵌入式系统的开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/JCTools/JCTools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JCTools&lt;/a&gt;：JDK中缺失的并发工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OpenHFT/Koloboke&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Koloboke&lt;/a&gt;：Hash set和hash map。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://trove.starlight-systems.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Trove&lt;/a&gt;：基础类型集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;ide&quot;&gt;IDE&lt;/h3&gt;&lt;br&gt;&lt;em&gt;简化开发的集成开发环境。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.eclipse.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eclipse&lt;/a&gt;：老牌开源项目，支持多种插件和编程语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://netbeans.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NetBeans&lt;/a&gt;：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;imagery&quot;&gt;图像处理&lt;/h3&gt;&lt;br&gt;&lt;em&gt;创建、评价和操作图片的支持库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/thebuzzmedia/imgscalr&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Imgscalr&lt;/a&gt;：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://square.github.io/picasso/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Picasso&lt;/a&gt;：安卓图片下载和图片缓存开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coobird/thumbnailator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thumbnailator&lt;/a&gt;：Thumbnailator是一个高质量Java缩略图开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zxing/zxing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ZXing&lt;/a&gt;：支持多种格式的一维、二维条形码图片处理开发库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;json&quot;&gt;JSON&lt;/h3&gt;&lt;br&gt;&lt;em&gt;简化JSON处理的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://owlike.github.io/genson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Genson&lt;/a&gt;：强大且易于使用的Java到JSON转换开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/gson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gson&lt;/a&gt;：支持在对象与JSON之间双向序列化，性能良好且可以实时调用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.fasterxml.com/JacksonHome&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jackson&lt;/a&gt;：与GSON类似，在频繁使用时性能更佳。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bluelinelabs/LoganSquare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LoganSquare&lt;/a&gt;：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;jvm-and-jdk&quot;&gt;JVM与JDK&lt;/h3&gt;&lt;br&gt;&lt;em&gt;目前的JVM和JDK实现。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jdk9.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JDK 9&lt;/a&gt;：JDK 9的早期访问版本。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenJDK&lt;/a&gt;：JDK开源实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;languages&quot;&gt;基于JVM的语言&lt;/h3&gt;&lt;br&gt;&lt;em&gt;除Java外，可以用来编写JVM应用程序的编程语言。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scala-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Scala&lt;/a&gt;：融合了面向对象和函数式编程思想的静态类型编程语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.groovy-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Groovy&lt;/a&gt;：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://clojure.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clojure&lt;/a&gt;：可看做现代版Lisp的动态类型语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ceylon-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ceylon&lt;/a&gt;：RedHat开发的面向对象静态类型编程语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kotlin&lt;/a&gt;：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;logging&quot;&gt;日志&lt;/h3&gt;&lt;br&gt;&lt;em&gt;记录应用程序行为日志的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://logging.apache.org/log4j/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Log4j 2&lt;/a&gt;：使用强大的插件和配置架构进行完全重写。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.elasticsearch.org/overview/kibana/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kibana&lt;/a&gt;：分析及可视化日志文件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://logback.qos.ch/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Logback&lt;/a&gt;：强健的日期开发库，通过Groovy提供很多有趣的选项。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://logstash.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;logstash&lt;/a&gt;：日志文件管理工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://metrics.codahale.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Metrics&lt;/a&gt;：通过JMX或HTTP发布参数，并且支持存储到数据库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.slf4j.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SLF4J&lt;/a&gt;：日志抽象层，需要与具体的实现配合使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;machine-learning&quot;&gt;机器学习&lt;/h3&gt;&lt;br&gt;&lt;em&gt;提供具体统计算法的工具。其算法可从数据中学习。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://flink.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Flink&lt;/a&gt;：快速、可靠的大规模数据处理引擎。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hadoop.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Hadoop&lt;/a&gt;：在商用硬件集群上用来进行大规模数据存储的开源软件框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mahout.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Mahout&lt;/a&gt;：专注协同过滤、聚类和分类的可扩展算法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://spark.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Spark&lt;/a&gt;：开源数据分析集群计算框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://deepdive.stanford.edu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DeepDive&lt;/a&gt;：从非结构化数据建立结构化信息并集成到已有数据库的工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://deeplearning4j.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deeplearning4j&lt;/a&gt;：分布式多线程深度学习开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://0xdata.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;H2O&lt;/a&gt;：用作大数据统计的分析引擎。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Weka&lt;/a&gt;：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;messaging&quot;&gt;消息传递&lt;/h3&gt;&lt;br&gt;&lt;em&gt;在客户端之间进行消息传递，确保协议独立性的工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/real-logic/Aeron&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aeron&lt;/a&gt;：高效可扩展的单播、多播消息传递工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://activemq.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache ActiveMQ&lt;/a&gt;：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://camel.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Camel&lt;/a&gt;：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Kafka&lt;/a&gt;：高吞吐量分布式消息系统。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hermes.allegro.tech&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hermes&lt;/a&gt;：快速、可靠的消息代理（Broker），基于Kafka构建。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hornetq.jboss.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JBoss HornetQ&lt;/a&gt;：清晰、准确、模块化，可以方便嵌入的消息工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zeromq/jeromq&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JeroMQ&lt;/a&gt;：ZeroMQ的纯Java实现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/igniterealtime/Smack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Smack&lt;/a&gt;：跨平台XMPP客户端函数库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;miscellaneous&quot;&gt;杂项&lt;/h3&gt;&lt;br&gt;&lt;em&gt;未分类其它资源。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/iluwatar/java-design-patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Design Patterns&lt;/a&gt;：实现并解释了最常见的设计模式。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/jimfs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jimfs&lt;/a&gt;：内存文件系统。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/lanterna/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lanterna&lt;/a&gt;：类似curses的简单console文本GUI函数库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lightadmin.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LightAdmin&lt;/a&gt;：可插入式CRUD UI函数库，可用来快速应用开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openrefine.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenRefine&lt;/a&gt;：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.robovm.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RoboVM&lt;/a&gt;：Java编写原生iOS应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;monitoring&quot;&gt;应用监控工具&lt;/h3&gt;&lt;br&gt;&lt;em&gt;监控生产环境中应用程序的工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.appdynamics.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AppDynamics&lt;/a&gt;：性能监测商业工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/javamelody/javamelody&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaMelody&lt;/a&gt;：性能监测和分析工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kamon.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kamon&lt;/a&gt;：Kamon用来监测在JVM上运行的应用程序。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://newrelic.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;New Relic&lt;/a&gt;：性能监测商业工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sematext.com/spm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SPM&lt;/a&gt;：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.takipi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Takipi&lt;/a&gt;：产品运行时错误监测及调试商业工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;native&quot;&gt;原生开发库&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来进行特定平台开发的原生开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twall/jna&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JNA&lt;/a&gt;：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;natural-language-processing&quot;&gt;自然语言处理&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来专门处理文本的函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://opennlp.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache OpenNLP&lt;/a&gt;：处理类似分词等常见任务的工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nlp.stanford.edu/software/corenlp.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CoreNLP&lt;/a&gt;：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://alias-i.com/lingpipe/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LingPipe&lt;/a&gt;：一组可以处理各种任务的工具集，支持POS标签、情感分析等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mallet.cs.umass.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mallet&lt;/a&gt;：统计学自然语言处理、文档分类、聚类、主题建模等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;networking&quot;&gt;网络&lt;/h3&gt;&lt;br&gt;&lt;em&gt;网络编程函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AsyncHttpClient/async-http-client&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Async Http Client&lt;/a&gt;：异步HTTP和WebSocket客户端函数库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grizzly.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Grizzly&lt;/a&gt;：NIO框架，在Glassfish中作为网络层使用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://netty.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Netty&lt;/a&gt;：构建高性能网络应用程序开发框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OkHttp&lt;/a&gt;：一个Android和Java应用的HTTP+SPDY客户端。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://undertow.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Undertow&lt;/a&gt;：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;orm&quot;&gt;ORM&lt;/h3&gt;&lt;br&gt;&lt;em&gt;A处理对象持久化的API。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ebean-orm.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ebean&lt;/a&gt;：支持快速数据访问和编码的ORM框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.eclipse.org/eclipselink/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EclipseLink&lt;/a&gt;：支持许多持久化标准，JPA、JAXB、JCA和SDO。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hibernate.org/orm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hibernate&lt;/a&gt;：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mybatis.github.io/mybatis-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyBatis&lt;/a&gt;：带有存储过程或者SQL语句的耦合对象（Couples object）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ormlite.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OrmLite&lt;/a&gt;：轻量级开发包，免除了其它ORM产品中的复杂性和开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;pdf&quot;&gt;PDF&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来帮助创建PDF文件的资源。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://xmlgraphics.apache.org/fop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache FOP&lt;/a&gt;：从XSL-FO创建PDF。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pdfbox.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache PDFBox&lt;/a&gt;：用来创建和操作PDF的工具集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dynamicreports.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DynamicReports&lt;/a&gt;：JasperReports的精简版。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/flyingsaucerproject/flyingsaucer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;flyingsaucer&lt;/a&gt;：XML/XHTML和CSS 2.1渲染器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://itextpdf.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iText&lt;/a&gt;：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://community.jaspersoft.com/project/jasperreports-library&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JasperReports&lt;/a&gt;：一个复杂的报表引擎。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;performance-analysis&quot;&gt;性能分析&lt;/h3&gt;&lt;br&gt;&lt;em&gt;性能分析、性能剖析及基准测试工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/giltene/jHiccup&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jHiccup&lt;/a&gt;：提供平台中JVM抛锚的日志和记录。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JMH&lt;/a&gt;：JVM为基准测试工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ej-technologies.com/products/jprofiler/overview.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JProfiler&lt;/a&gt;：商业分析器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/LatencyUtils/LatencyUtils&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LatencyUtils&lt;/a&gt;：测量和报告延迟的工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://visualvm.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VisualVM&lt;/a&gt;：对运行中的应用程序信息提供了可视化界面。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yourkit.com/features/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YourKit Java Profiler&lt;/a&gt;：商业分析器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;reactive-libraries&quot;&gt;响应式开发库&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来开发响应式应用程序的开发库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reactive Streams&lt;/a&gt;：异步流处理标准，支持非阻塞式反向压力（backpressure）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://projectreactor.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reactor&lt;/a&gt;：构建响应式快速数据（fast-data）应用程序的开发库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/RxJava&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RxJava&lt;/a&gt;：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;rest-frameworks&quot;&gt;REST框架&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来创建RESTful 服务的框架。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://dropwizard.github.io/dropwizard/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dropwizard&lt;/a&gt;：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/feign&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Feign&lt;/a&gt;：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jersey.java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jersey&lt;/a&gt;：JAX-RS参考实现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://resteasy.jboss.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RESTEasy&lt;/a&gt;：经过JAX-RS规范完全认证的可移植实现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/RestExpress/RestExpress&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RestExpress&lt;/a&gt;：一个Java类型安全的REST客户端。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://restx.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RestX&lt;/a&gt;：基于朱洁处理和编译时源码生成的框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit&lt;/a&gt;：类型安全的REST客户端。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.sparkjava.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark&lt;/a&gt;：受到Sinatra启发的Java REST框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://helloreverb.com/developers/swagger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swagger&lt;/a&gt;：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;science&quot;&gt;科学计算与分析&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用于科学计算和分析的函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jwork.org/dmelt/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DataMelt&lt;/a&gt;：用于科学计算、数据分析及数据可视化的开发环境。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jgrapht/jgrapht&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JGraphT&lt;/a&gt;：支持数学图论对象和算法的图形库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jscience.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JScience&lt;/a&gt;：用来进行科学测量和单位的一组类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;search&quot;&gt;搜索引擎&lt;/h3&gt;&lt;br&gt;&lt;em&gt;文档索引引擎，用于搜索和分析。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://lucene.apache.org/solr/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Solr&lt;/a&gt;：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.elasticsearch.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Elasticsearch&lt;/a&gt;：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;security&quot;&gt;安全&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用于处理安全、认证、授权或会话管理的函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://shiro.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Shiro&lt;/a&gt;：执行认证、授权、加密和会话管理。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bouncycastle.org/java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bouncy Castle&lt;/a&gt;：多用途加密开发库。支持JCA提供者（JCA provider)，涵盖了从基础的帮助函数到PGP/SMIME操作。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cryptomator.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cryptomator&lt;/a&gt;：在云上进行客户端跨平台透明加密。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://keycloak.jboss.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keycloak&lt;/a&gt;：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://picketlink.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PicketLink&lt;/a&gt;：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;serialization&quot;&gt;序列化&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来高效处理序列化的函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/flatbuffers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FlatBuffers&lt;/a&gt;：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/EsotericSoftware/kryo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kryo&lt;/a&gt;：快速、高效的对象图形序列化框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/RuedigerMoeller/fast-serialization&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FST&lt;/a&gt;：提供兼容JDK的高性能对象图形序列化。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/msgpack/msgpack-java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessagePack&lt;/a&gt;：一种高效的二进制序列化格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;server&quot;&gt;应用服务器&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用来部署应用程序的服务器。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tomcat.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Tomcat&lt;/a&gt;：针对Servlet和JSP的应用服务器，健壮性好且适用性强。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://tomee.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache TomEE&lt;/a&gt;：Tomcat加Java EE。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jetty&lt;/a&gt;：轻量级、小巧的应用服务器，通常会嵌入到项目中。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.ibm.com/wasdev/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WebSphere Liberty&lt;/a&gt;：轻量级、模块化应用服务器，由IBM开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.wildfly.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WildFly&lt;/a&gt;：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;template-engine&quot;&gt;模板引擎&lt;/h3&gt;&lt;br&gt;&lt;em&gt;在模板中替换表达式的工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://velocity.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Velocity&lt;/a&gt;：提供HTML页面模板、email模板和通用开源代码生成器模板。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freemarker.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FreeMarker&lt;/a&gt;：通用模板引擎，不需要任何重量级或自己使用的依赖关系。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jknack.github.io/handlebars.java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Handlebars.java&lt;/a&gt;：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.thymeleaf.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thymeleaf&lt;/a&gt;：旨在替换JSP，支持XML文件的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;testing&quot;&gt;测试&lt;/h3&gt;&lt;br&gt;&lt;em&gt;测试内容从对象到接口，涵盖性能测试和基准测试工具。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jmeter.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache JMeter&lt;/a&gt;：功能性测试和性能评测。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://arquillian.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Arquillian&lt;/a&gt;：集成测试和功能行测试平台，集成Java EE容器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joel-costigliola.github.io/assertj/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AssertJ&lt;/a&gt;：支持流式断言提高测试的可读性。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jayway/awaitility&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Awaitility&lt;/a&gt;：用来同步异步操作的DSL。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cucumber/cucumber-jvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cucumber&lt;/a&gt;：BDD测试框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gatling.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gatling&lt;/a&gt;：设计为易于使用、可维护的和高性能负载测试工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hamcrest.org/JavaHamcrest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hamcrest&lt;/a&gt;：可用来灵活创建意图（intent）表达式的匹配器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jmockit.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JMockit&lt;/a&gt;：用来模拟静态、final方法等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://junit.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JUnit&lt;/a&gt;：通用测试框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mockito/mockito&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mockito&lt;/a&gt;：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jayway/powermock&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PowerMock&lt;/a&gt;： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jayway/rest-assured&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;REST Assured&lt;/a&gt;：为REST/HTTP服务提供方便测试的Java DSL。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://selenide.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Selenide&lt;/a&gt;：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.seleniumhq.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Selenium&lt;/a&gt;：为Web应用程序提供可移植软件测试框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.spockframework.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spock&lt;/a&gt;：JUnit-compatible framework featuring an expressive Groovy-derived specification language.兼容JUnit框架，支持衍生的Groovy范的语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://testng.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TestNG&lt;/a&gt;：测试框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/truth&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Truth&lt;/a&gt;：Google的断言和命题（proposition）框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.unitils.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unitils&lt;/a&gt;：模块化测试函数库，支持单元测试和集成测试。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiremock.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WireMock&lt;/a&gt;：Web Service测试桩（Stub）和模拟函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;utility&quot;&gt;通用工具库&lt;/h3&gt;&lt;br&gt;&lt;em&gt;通用工具类函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://commons.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Commons&lt;/a&gt;：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://args4j.kohsuke.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;args4j&lt;/a&gt;：命令行参数解析器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.crashub.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CRaSH&lt;/a&gt;：为运行进行提供CLI。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gephi/gephi/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gephi&lt;/a&gt;：可视化跨平台网络图形化操作程序。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Guava&lt;/a&gt;：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jade.tilab.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JADE&lt;/a&gt;：构建、调试多租户系统的框架和环境。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javatuples.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javatuples&lt;/a&gt;：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jcommander.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JCommander&lt;/a&gt;：命令行参数解析器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://protege.stanford.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Protégé&lt;/a&gt;：提供存在论（ontology）编辑器以及构建知识系统的框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;web-crawling&quot;&gt;网络爬虫&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用于分析网站内容的函数库。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://nutch.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Nutch&lt;/a&gt;：可用于生产环境的高度可扩展、可伸缩的网络爬虫。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yasserg/crawler4j&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crawler4j&lt;/a&gt;：简单的轻量级网络爬虫。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jsoup.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSoup&lt;/a&gt;：刮取、解析、操作和清理HTML。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;web-frameworks&quot;&gt;Web框架&lt;/h3&gt;&lt;br&gt;&lt;em&gt;用于处理Web应用程序不同层次间通讯的框架。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tapestry.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Tapestry&lt;/a&gt;：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wicket.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Wicket&lt;/a&gt;：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gwtproject.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Web Toolkit&lt;/a&gt;：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP API、JUnit集成、国际化支持和GUI控件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grails.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Grails&lt;/a&gt;：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ninjaframework.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ninja&lt;/a&gt;：Java全栈Web开发框架。非常稳固、快速和高效。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pippo.ro/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pippo&lt;/a&gt;：小型、高度模块化的类Sinatra框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.playframework.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Play&lt;/a&gt;：使用约定而非配置，支持代码热加载并在浏览器中显示错误。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://primefaces.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PrimeFaces&lt;/a&gt;：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ratpack.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ratpack&lt;/a&gt;：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Boot&lt;/a&gt;：微框架，简化了Spring新程序的开发过程。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring&lt;/a&gt;：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vaadin.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vaadin&lt;/a&gt;：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;resources&quot;&gt;资源&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;communities&quot;&gt;社区&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.reddit.com/r/java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;r/java&lt;/a&gt;：Reddit的Java子社区。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/tagged/java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;：问答平台。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://virtualjug.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vJUG&lt;/a&gt;：虚拟Java用户组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;influential-books&quot;&gt;有影响力的书&lt;/h3&gt;&lt;br&gt;&lt;em&gt;具有广泛影响且值得阅读的Java经典书籍。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.cn/gp/product/0321356683/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=0321356683&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Effective Java (2nd Edition)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/Java-Action-Lambdas-functional-style-programming/dp/1617291994/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java 8 in Action&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java Concurrency in Practice | Java并发编程实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;hhttp://www.amazon.cn/gp/product/B0011C3CVA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B0011C3CVA&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thinking in Java | Java编程思想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;podcasts&quot;&gt;播客&lt;/h3&gt;&lt;br&gt;&lt;em&gt;可以一边编程一边听的东西。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://virtualjug.com/podcast/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java Council&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaposse.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java Posse&lt;/a&gt;：Discontinued as of 02/2015.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;weibo-weixin&quot;&gt;微博、微信公众号&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ImportNew：是最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;ImportNew 微博：&lt;a href=&quot;http://weibo.com/importnew&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@ImportNew&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;twitter&quot;&gt;Twitter&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/AdamBien/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adam Bien&lt;/a&gt;：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/agoncal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Antonio Goncalves&lt;/a&gt;：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/arungupta/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Arun Gupta&lt;/a&gt;：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/brunoborges&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bruno Borges&lt;/a&gt;：Oracle产品经理、Java Jock。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/edburns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ed Burns&lt;/a&gt;：Oracle技术团队顾问。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/baeldung&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eugen Paraschiv&lt;/a&gt;：Spring安全课程作者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/JavaFXpert&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;James Weaver&lt;/a&gt;：Java、JavaFX、IoT开发者、作者和演讲者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/Java_EE/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java EE&lt;/a&gt;：Java EE Twitter官方账号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/Oraclejavamag&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java Magazine&lt;/a&gt;：Java杂志官方账号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/javanetbuzz/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java.net&lt;/a&gt;：Java.net官方账号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;：Java Twitter官方账号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/javinpaul&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javin Paul&lt;/a&gt;：知名Java博客作者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/lukaseder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lukas Eder&lt;/a&gt;：Data Geekery（jOOQ）创始人兼CEO。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/mariofusco&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mario Fusco&lt;/a&gt;：RedHatter、JUG协调、活跃讲师和作者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/mreinhold&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mark Reinhold&lt;/a&gt;：Oracle首席架构师、Java平台开发组。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/karianna&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Martijn Verburg&lt;/a&gt;：London JUG co-leader、演讲者、作家、Java Champion等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/OpenJDK&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenJDK&lt;/a&gt;：OpenJDK官方账号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/reza_rahman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reza Rahman&lt;/a&gt;：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/sjmaple&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Simon Maple&lt;/a&gt;：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/jodastephen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stephen Colebourne&lt;/a&gt;： Java Champion、演讲者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/kablosna&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tim Boudreau&lt;/a&gt;：作家、NetBeans大牛。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/trisha_gee&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Trisha Gee&lt;/a&gt;：Java Champion、演讲者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;websites&quot;&gt;知名网站&lt;/h3&gt;&lt;br&gt;&lt;em&gt;值得关注的Java技术站点。&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4&gt;中文站点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.importnew.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImportNew&lt;/a&gt;（ImportNew 专注 Java 技术）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;英文站点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://android-arsenal.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Arsenal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/javaguide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Java Style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;InfoQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java Code Geeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jooq.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java, SQL, and jOOQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://java.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://java.dzone.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javalobby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaworld.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaWorld&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jaxenter.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JAXenter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zeroturnaround.com/rebellabs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RebelLabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaspecialists.eu/archive/archive.jsp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Java Specialist’ Newsletter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.takipi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Takipi Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.theserverside.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TheServerSide.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.thoughts-on-java.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thoughts On Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vanillajava.blogspot.ch/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vanilla Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vladmihalcea.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vlad Mihalcea on Hibernate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voxxed.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Voxxed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;声明：本文仅作个人收藏，非本人编写。原文请访问：&lt;a href=&quot;https://github.com/jobbole/awesome-java-cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jobbole/awesome-java-cn&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gonggaofeng.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 有哪些实用技巧</title>
    <link href="http://gonggaofeng.me/2015/12/20/Sublime-Text-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://gonggaofeng.me/2015/12/20/Sublime-Text-有哪些实用技巧/</id>
    <published>2015-12-20T06:04:10.000Z</published>
    <updated>2016-03-28T16:58:12.000Z</updated>
    
    <content type="html">&lt;p&gt;Sublime一些好用的技巧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常用热键&quot;&gt;&lt;a href=&quot;#常用热键&quot; class=&quot;headerlink&quot; title=&quot;常用热键&quot;&gt;&lt;/a&gt;常用热键&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多重文本选择：ctrl + cmd + g&lt;/li&gt;
&lt;li&gt;多重光标选择：shift + ctrl + up/down&lt;/li&gt;
&lt;li&gt;选择标签本身：shift + ctrl + a&lt;/li&gt;
&lt;li&gt;选择标签内容：shift + cmd + a&lt;/li&gt;
&lt;li&gt;重新打开刚刚关闭的标签页：cmd + shift + t&lt;/li&gt;
&lt;li&gt;括号前后移动光标：ctrl + m&lt;/li&gt;
&lt;li&gt;向光标前插入一行：shift + cmd + enter&lt;/li&gt;
&lt;li&gt;向光标后插入一行：cmd + enter&lt;/li&gt;
&lt;li&gt;快速折叠文件内所有函数：cmd + k ,1 （数字表示级别）&lt;/li&gt;
&lt;li&gt;折叠属性：cmd + k, t （编辑 HTML 模板最有用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Goto&quot;&gt;&lt;a href=&quot;#Goto&quot; class=&quot;headerlink&quot; title=&quot;Goto&quot;&gt;&lt;/a&gt;Goto&lt;/h2&gt;&lt;p&gt;一共有四种 Goto ：&lt;br&gt;cmd+p  文件定位&lt;br&gt;cmd+;  词语定位 #&lt;br&gt;cmd+r  函数定位 @&lt;br&gt;cmd+g  行号定位 :&lt;/p&gt;
&lt;h2 id=&quot;多文件中搜索&quot;&gt;&lt;a href=&quot;#多文件中搜索&quot; class=&quot;headerlink&quot; title=&quot;多文件中搜索&quot;&gt;&lt;/a&gt;多文件中搜索&lt;/h2&gt;&lt;p&gt;Where 中可以使用通配符，比如 &lt;em&gt;.js, &lt;/em&gt;.less 将在项目中所有后缀为 js 和 less 的文件中搜索。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime一些好用的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Sublime" scheme="http://gonggaofeng.me/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>VIM光标移动</title>
    <link href="http://gonggaofeng.me/2015/12/19/VIM%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8/"/>
    <id>http://gonggaofeng.me/2015/12/19/VIM光标移动/</id>
    <published>2015-12-19T15:41:51.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;Vim一些快捷键&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;移动光标 上:k nk:向上移动n行 9999k或gg可以移到第一行 G移到最后一行 下:j nj:向下移动n行 左:h nh:向左移动n列 右:l nl:向右移动n列&lt;/p&gt;
&lt;p&gt;w：光标以单词向前移动 nw：光标向前移动n个单词 光标到单词的第一个字母上 b：与w相反 e: 光标以单词向前移动 ne：光标向前移动n个单词 光标到单词的最后一个字母上 ge:与e相反&lt;/p&gt;
&lt;p&gt;$:移动光标到行尾 n$:移动到第n行的行尾 0（Num）：移动光标到行首 ^:移动光标到行首第一个非空字符上去&lt;/p&gt;
&lt;p&gt;f:移动光标到当前行的字符a上，nf移动光标到当前行的第n个a字符上 F:相反&lt;/p&gt;
&lt;p&gt;%:移动到与制匹配的括号上去（），{}，[]，&amp;lt;&amp;gt;等。&lt;/p&gt;
&lt;p&gt;nG:移动到第n行上 G:到最后一行&lt;/p&gt;
&lt;p&gt;CTRL＋G 得到当前光标在文件中的位置&lt;/p&gt;
&lt;p&gt;向前翻页：CTRL+F 向下移动半屏：CTRL＋G&lt;/p&gt;
&lt;p&gt;向后翻页：CTRL+B&lt;/p&gt;
&lt;p&gt;到文件开头 gg 到文件结尾 shift+g&lt;/p&gt;
&lt;p&gt;存盘： :q! :不存盘退出 :e! :放弃修改文件内容，重新载入该文件编辑 :wq ：存盘退出&lt;/p&gt;
&lt;p&gt;dw：删除一个单词,需将光标移到单词的第一个字母上，按dw，如果光标在单词任意位置，用daw dnw:删除n个单词 dne:也可，只是删除到单词尾 dnl:向右删除n个字母 dnh:向左删除n个字母 dnj:向下删除n行 dnk:向上删除n行 d$：删除当前光标到改行的行尾的字母 dd：删除一行 cnw[word]:将n个word改变为word cc:改变整行 C$:改变到行尾&lt;/p&gt;
&lt;p&gt;J: 删除换行符，将光标移到改行，按shift+j删除行尾的换行符，下一行接上来了. u: 撤销前一次的操作 shif+u(U):撤销对该行的所有操作。&lt;/p&gt;
&lt;p&gt;:set showmode :设置显示工作模式&lt;/p&gt;
&lt;p&gt;o：在当前行的下面另起一行 O（shift+o)：在当前行的上面另起一行&lt;/p&gt;
&lt;p&gt;nk或nj：光标向上或向下移n行，n为数字 an!【ESC】：在行后面加n个感叹号(!) nx:执行n次x(删除)操作&lt;/p&gt;
&lt;p&gt;ZZ：保存当前文档并退出VIM&lt;/p&gt;
&lt;p&gt;:help ：查看帮助文档，在这之中，按CTRL+] 进入超连接，按CTRL＋O 返回。 :help subject :看某一主题的帮助，ZZ 退出帮助&lt;/p&gt;
&lt;p&gt;:set number / set nonumber :显示/不显示行号 :set ruler /set noruler:显示/不显示标尺&lt;/p&gt;
&lt;p&gt;/pattern 正方向搜索一个字符模式 ?pattern 反方向搜索一个字符模式 然后按n 继续向下找&lt;/p&gt;
&lt;p&gt;把光标放到某个单词上面，然后按×号键，表示查找这个单词 查找整个单词：/\&lt;/p&gt;
&lt;p&gt;:set hlsearch 高亮显示查找到的单词 :set nohlsearch 关闭改功能&lt;/p&gt;
&lt;p&gt;m[a-z]:在文中做标记，标记号可为a-z的26个字母，用`a可以移动到标记a处&lt;/p&gt;
&lt;p&gt;r:替换当前字符 nr字符：替换当前n个字符&lt;/p&gt;
&lt;p&gt;查找替换： way1: /【word】 :查找某个word cw【newword】:替换为新word n: 继续查找 .: 执行替换&lt;/p&gt;
&lt;p&gt;way2: :s/string1/string2/g:在一行中将string1替换为string2,g表示执行 用c表示需要确认 :num1,num2 s/string1/string2/g:在行num1至num2中间将string1替换为string2 :1,$ s/string1/string2/g:在全文中将string1替换为string2&lt;/p&gt;
&lt;p&gt;v:进入visual 模式 【ESC】退出 V:shift+v 进入行的visual 模式 CTRL+V:进如块操作模式用o和O改变选择的边的大小。&lt;/p&gt;
&lt;p&gt;粘贴：p，这是粘贴用x或d删除的文本 复制： ynw：复制n个单词 yy：复制一行 ynl:复制n个字符 y$:复制当前光标至行尾处 nyy:拷贝n行 完了用p粘贴&lt;/p&gt;
&lt;p&gt;:split:分割一个窗口 :split file.c ：为另一个文件file.c分隔窗口 :nsplit file.c: 为另一个文件file.c分隔窗口，并指定其行数 CTRL＋W在窗口中切换 :close：关闭当前窗口&lt;/p&gt;
&lt;p&gt;在所有行插入相同的内容如include&amp;lt;，操作方法如下： 将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后 按I（shift+i)，后插入要插入的文本，按[ESC]完成。&lt;/p&gt;
&lt;p&gt;:read file.c 将文件file.c的内容插入到当前光标所在的下面 :0read file.c 将文件file.c的内容插入到当前文件的开始处(第0行） :nread file.c 将文件file.c的内容插入到当前文件的第n行后面 :read !cmd :将外部命令cmd的输出插如到当前光标所在的下面&lt;/p&gt;
&lt;p&gt;:n1,n2 write temp.c 将本文件中的n1,到n2行写入temp.c这个文件中去&lt;/p&gt;
&lt;p&gt;CTRL＋L刷新屏幕 shift + &amp;lt; 左移一行 shift + &amp;gt; 右移一行&lt;/p&gt;
&lt;p&gt;u: undo CTRL+R: re-do J: 合并一行 CTRL+p 自动完成功能 CTRL+g 查看当前文件全路径&lt;/p&gt;
&lt;p&gt;q[a-z] 开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏。 用reg显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z]。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Vim一些快捷键&lt;/p&gt;
    
    </summary>
    
    
      <category term="Editor" scheme="http://gonggaofeng.me/tags/Editor/"/>
    
  </entry>
  
  <entry>
    <title>android Bitmap对象的创建过程</title>
    <link href="http://gonggaofeng.me/2015/12/19/Bitmap%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://gonggaofeng.me/2015/12/19/Bitmap对象的创建过程/</id>
    <published>2015-12-19T08:47:02.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;本文分析了从Java层到Native层分析了Bitmap对象的创建过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Bitmap在Android4.0之后将Bitmap的内存从Native层转移到Java层了。&lt;br&gt;在Java层，创建一个Bitmap对象需要使用Bitmap的createBitmap的系列方法,Bitmap通过下面的方法来时创建Bitmap对象。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private static Bitmap createBitmap(DisplayMetrics display, int width, int height,&amp;#10;            Config config, boolean hasAlpha) &amp;#123;&amp;#10;        if (width &amp;#60;= 0 || height &amp;#60;= 0) &amp;#123;&amp;#10;            throw new IllegalArgumentException(&amp;#34;width and height must be &amp;#62; 0&amp;#34;);&amp;#10;        &amp;#125;&amp;#10;        Bitmap bm = nativeCreate(null, 0, width, width, height, config.nativeInt, true);&amp;#10;        if (display != null) &amp;#123;&amp;#10;            bm.mDensity = display.densityDpi;&amp;#10;        &amp;#125;&amp;#10;        bm.setHasAlpha(hasAlpha);&amp;#10;        if (config == Config.ARGB_8888 &amp;#38;&amp;#38; !hasAlpha) &amp;#123;&amp;#10;            nativeErase(bm.mFinalizer.mNativeBitmap, 0xff000000);&amp;#10;        &amp;#125;&amp;#10;        // No need to initialize the bitmap to zeroes with other configs;&amp;#10;        // it is backed by a VM byte array which is by definition preinitialized&amp;#10;        // to all zeroes.&amp;#10;        return bm;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码位于framework/base/core/graphics/java/android/graphics/Bitmap.java&lt;/p&gt;
&lt;p&gt;在createBitmap方法中通过nativeCreate方法来创建Bitmap对象，nativeCreate方法的申明如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private static native Bitmap nativeCreate(int[] colors, int offset,&amp;#10;                                              int stride, int width, int height,&amp;#10;                                              int nativeConfig, boolean mutable);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;nativeCreate的参数colors是像素点颜色数组，offset是数组的起始偏移量，stride是每个像素颜色的跨越值，width是bitmap 的宽度值，height是bitmap 的高度值，nativeConfig是Config的int值，Config是一个枚举类型，代码下面列出，nativeConfigInt也就是config对象的int型表示。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public enum Config &amp;#123;&amp;#10;        // these native values must match up with the enum in SkBitmap.h&amp;#10;&amp;#10;        ALPHA_8     (1),&amp;#10;&amp;#10;        RGB_565     (3),&amp;#10;&amp;#10;        @Deprecated&amp;#10;        ARGB_4444   (4),&amp;#10;&amp;#10;        ARGB_8888   (5);&amp;#10;&amp;#10;        final int nativeInt;&amp;#10;&amp;#10;        private static Config sConfigs[] = &amp;#123;&amp;#10;            null, ALPHA_8, null, RGB_565, ARGB_4444, ARGB_8888&amp;#10;        &amp;#125;;&amp;#10;&amp;#10;        Config(int ni) &amp;#123;&amp;#10;            this.nativeInt = ni;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        static Config nativeToConfig(int ni) &amp;#123;&amp;#10;            return sConfigs[ni];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;nativeCreate在Native层对应的方法是framework/base/core/jni/android/graphics/Bitmap.cpp文件中的Bitmap_creator方法中。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static jobject Bitmap_creator(JNIEnv* env, jobject, jintArray jColors,&amp;#10;                              jint offset, jint stride, jint width, jint height,&amp;#10;                              jint configHandle, jboolean isMutable) &amp;#123;&amp;#10;    SkColorType colorType = GraphicsJNI::legacyBitmapConfigToColorType(configHandle);&amp;#10;    if (NULL != jColors) &amp;#123;&amp;#10;        size_t n = env-&amp;#62;GetArrayLength(jColors);&amp;#10;        if (n &amp;#60; SkAbs32(stride) * (size_t)height) &amp;#123;&amp;#10;            doThrowAIOOBE(env);&amp;#10;            return NULL;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // ARGB_4444 is a deprecated format, convert automatically to 8888&amp;#10;    if (colorType == kARGB_4444_SkColorType) &amp;#123;&amp;#10;        colorType = kN32_SkColorType;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    SkBitmap bitmap;&amp;#10;    bitmap.setInfo(SkImageInfo::Make(width, height, colorType, kPremul_SkAlphaType));&amp;#10;&amp;#10;    Bitmap* nativeBitmap = GraphicsJNI::allocateJavaPixelRef(env, &amp;#38;bitmap, NULL);&amp;#10;    if (!nativeBitmap) &amp;#123;&amp;#10;        return NULL;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (jColors != NULL) &amp;#123;&amp;#10;        GraphicsJNI::SetPixels(env, jColors, offset, stride,&amp;#10;                0, 0, width, height, bitmap);&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return GraphicsJNI::createBitmap(env, nativeBitmap,&amp;#10;            getPremulBitmapCreateFlags(isMutable));&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里首先调用GraphicsJNI::legacyBitmapConfigToColorType将configHandle转换成SkColorType,configHandle是Java层的Config对象的int型表示，legacyBitmapConfigToColorType函数如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SkColorType GraphicsJNI::legacyBitmapConfigToColorType(jint legacyConfig) &amp;#123;&amp;#10;    const uint8_t gConfig2ColorType[] = &amp;#123;&amp;#10;        kUnknown_SkColorType,&amp;#10;        kAlpha_8_SkColorType,&amp;#10;        kIndex_8_SkColorType,&amp;#10;        kRGB_565_SkColorType,&amp;#10;        kARGB_4444_SkColorType,&amp;#10;        kN32_SkColorType&amp;#10;    &amp;#125;;&amp;#10;&amp;#10;    if (legacyConfig &amp;#60; 0 || legacyConfig &amp;#62; kLastEnum_LegacyBitmapConfig) &amp;#123;&amp;#10;        legacyConfig = kNo_LegacyBitmapConfig;&amp;#10;    &amp;#125;&amp;#10;    return static_cast&amp;#60;SkColorType&amp;#62;(gConfig2ColorType[legacyConfig]);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后colors数组不为NULL的话，检查colors数组的合法性，如果colors的长度小于stride*height，说明colors数组中要跳过的数大于数组的长度，也就是colors数组中没有合法的像素值。如果colors数组是合法的，则继续执行。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SkBitmap bitmap;&amp;#10;   bitmap.setInfo(SkImageInfo::Make(width, height, colorType, kPremul_SkAlphaType));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SkImageInfo()&amp;#10;       : fWidth(0)&amp;#10;       , fHeight(0)&amp;#10;       , fColorType(kUnknown_SkColorType)&amp;#10;       , fAlphaType(kUnknown_SkAlphaType)&amp;#10;       , fProfileType(kLinear_SkColorProfileType)&amp;#10;   &amp;#123;&amp;#125;&amp;#10;&amp;#10;   static SkImageInfo Make(int width, int height, SkColorType ct, SkAlphaType at,&amp;#10;                           SkColorProfileType pt = kLinear_SkColorProfileType) &amp;#123;&amp;#10;       return SkImageInfo(width, height, ct, at, pt);&amp;#10;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SkImageInfo定义在external/skia/include/core/SkImageInfo.h文件中&lt;br&gt;创建一个SkBitmap对象，调用SkImageInfo::Make方法通过从Java层传下来的width，height以及上面转换得到的colorType，以及kPremul_SkAlphaType来得到一个SkBitmapInfo对象，kPremul_SkAlphaType是一个SkAlphaType类型，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum SkAlphaType &amp;#123;&amp;#10;&amp;#9;//All pixels are stored as opaque&amp;#10;    kUnknown_SkAlphaType,&amp;#10;&amp;#10;    kOpaque_SkAlphaType,&amp;#10;&amp;#10;    kPremul_SkAlphaType,&amp;#10;&amp;#10;    kUnpremul_SkAlphaType,&amp;#10;&amp;#10;    kLastEnum_SkAlphaType = kUnpremul_SkAlphaType&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后调用SkBitmap.setInfo将得到SkImageInfo记录下来。调用GraphicsJNI::allocateJavaPixelRef方法，此方法是用于在Java层给Bitmap对象分配内存。该方法实现位于framework/base/jni/android/graphics/Graphics.cpp文件中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android::Bitmap* GraphicsJNI::allocateJavaPixelRef(JNIEnv* env, SkBitmap* bitmap,&amp;#10;                                             SkColorTable* ctable) &amp;#123;&amp;#10;    const SkImageInfo&amp;#38; info = bitmap-&amp;#62;info();&amp;#10;    if (info.fColorType == kUnknown_SkColorType) &amp;#123;&amp;#10;        doThrowIAE(env, &amp;#34;unknown bitmap configuration&amp;#34;);&amp;#10;        return NULL;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    size_t size;&amp;#10;    if (!computeAllocationSize(*bitmap, &amp;#38;size)) &amp;#123;&amp;#10;        return NULL;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // we must respect the rowBytes value already set on the bitmap instead of&amp;#10;    // attempting to compute our own.&amp;#10;    const size_t rowBytes = bitmap-&amp;#62;rowBytes();&amp;#10;&amp;#10;    jbyteArray arrayObj = (jbyteArray) env-&amp;#62;CallObjectMethod(gVMRuntime,&amp;#10;                                                             gVMRuntime_newNonMovableArray,&amp;#10;                                                             gByte_class, size);&amp;#10;    if (env-&amp;#62;ExceptionCheck() != 0) &amp;#123;&amp;#10;        return NULL;&amp;#10;    &amp;#125;&amp;#10;    SkASSERT(arrayObj);&amp;#10;    jbyte* addr = (jbyte*) env-&amp;#62;CallLongMethod(gVMRuntime, gVMRuntime_addressOf, arrayObj);&amp;#10;    if (env-&amp;#62;ExceptionCheck() != 0) &amp;#123;&amp;#10;        return NULL;&amp;#10;    &amp;#125;&amp;#10;    SkASSERT(addr);&amp;#10;    android::Bitmap* wrapper = new android::Bitmap(env, arrayObj, (void*) addr,&amp;#10;            info, rowBytes, ctable);&amp;#10;    wrapper-&amp;#62;getSkBitmap(bitmap);&amp;#10;    // since we&amp;#39;re already allocated, we lockPixels right away&amp;#10;    // HeapAllocator behaves this way too&amp;#10;    bitmap-&amp;#62;lockPixels();&amp;#10;&amp;#10;    return wrapper;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个方法中，首先info的fColorType和kUnknown_SkColorType相等的话，表示要创建的Bitmap的colorType是错误的，方法返回。否则继续执行，计算需要分配的大小，如果大小等于0，就不需要创建，直接返回。不等于0的话，通过调用jni的CallObjectMethod来调用gVimRuntime的gVMRuntime_newNonMovableArray方法来创建一个数组，这个数组类型和长度分别用gByte_class和size表示。CallObjectMethod函数返回一个jbyteArray，此时，在Java层已经创建了一个长度为size的byte数组。&lt;/p&gt;
&lt;p&gt;数组创建完毕后，通过调用jni的CallLongMethod方法调用gVMRuntime对象的gVMRuntime_addressOf方法来获取上面的到arrayObj的数组地址。&lt;/p&gt;
&lt;p&gt;得到数组地址后，创建一个Native层的Bitmap对象wrapper，调用wrapper的getSkBitmap方法为bitmap设置了一些参数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void Bitmap::getSkBitmap(SkBitmap* outBitmap) &amp;#123;&amp;#10;    assertValid();&amp;#10;    android::AutoMutex _lock(mLock);&amp;#10;    // Safe because mPixelRef is a WrappedPixelRef type, otherwise rowBytes()&amp;#10;    // would require locking the pixels first.&amp;#10;    outBitmap-&amp;#62;setInfo(mPixelRef-&amp;#62;info(), mPixelRef-&amp;#62;rowBytes());&amp;#10;    outBitmap-&amp;#62;setPixelRef(refPixelRefLocked())-&amp;#62;unref();&amp;#10;    outBitmap-&amp;#62;setHasHardwareMipMap(hasHardwareMipMap());&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;调用SkBitmap对象bitmap的lockPixels方法锁定像素数据后，GraphicsJNI::allocateJavaPixelRef函数返回wrapper对象，回到Bitmap_creator方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static jobject Bitmap_creator(JNIEnv* env, jobject, jintArray jColors,&amp;#10;                              jint offset, jint stride, jint width, jint height,&amp;#10;                              jint configHandle, jboolean isMutable) &amp;#123;&amp;#10;    ......&amp;#10;&amp;#10;    Bitmap* nativeBitmap = GraphicsJNI::allocateJavaPixelRef(env, &amp;#38;bitmap, NULL);&amp;#10;    if (!nativeBitmap) &amp;#123;&amp;#10;        return NULL;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (jColors != NULL) &amp;#123;&amp;#10;        GraphicsJNI::SetPixels(env, jColors, offset, stride,&amp;#10;                0, 0, width, height, bitmap);&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return GraphicsJNI::createBitmap(env, nativeBitmap,&amp;#10;            getPremulBitmapCreateFlags(isMutable));&amp;#10;&amp;#125;          getPremulBitmapCreateFlags(isMutable));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果GraphicsJNI::allocateJavaPixelRef返回的Native 层的Bitmap对象为NULL，函数返回。否则，函数继续执行。&lt;br&gt;如果jColors不为NULL，那么将jColors中表示的像素值传递给前面创建在Java层的数组中。&lt;br&gt;调用GraphicsJNI::createBitmap来创建Java层的Bitmap对象。函数定义在framework/base/jni/android/graphics/Graphics.cpp中&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jobject GraphicsJNI::createBitmap(JNIEnv* env, android::Bitmap* bitmap,&amp;#10;        int bitmapCreateFlags, jbyteArray ninePatchChunk, jobject ninePatchInsets,&amp;#10;        int density) &amp;#123;&amp;#10;    bool isMutable = bitmapCreateFlags &amp;#38; kBitmapCreateFlag_Mutable;&amp;#10;    bool isPremultiplied = bitmapCreateFlags &amp;#38; kBitmapCreateFlag_Premultiplied;&amp;#10;    // The caller needs to have already set the alpha type properly, so the&amp;#10;    // native SkBitmap stays in sync with the Java Bitmap.&amp;#10;    assert_premultiplied(bitmap-&amp;#62;info(), isPremultiplied);&amp;#10;&amp;#10;    jobject obj = env-&amp;#62;NewObject(gBitmap_class, gBitmap_constructorMethodID,&amp;#10;            reinterpret_cast&amp;#60;jlong&amp;#62;(bitmap), bitmap-&amp;#62;javaByteArray(),&amp;#10;            bitmap-&amp;#62;width(), bitmap-&amp;#62;height(), density, isMutable, isPremultiplied,&amp;#10;            ninePatchChunk, ninePatchInsets);&amp;#10;    hasException(env); // For the side effect of logging.&amp;#10;    return obj;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里主要是调用jni的NewObject来创建了一个Java层的Bitmap对象，gBitmap_class代表的Java层的Bitmap类名&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int register_android_graphics_Graphics(JNIEnv* env)&amp;#10;&amp;#123;&amp;#10;    ......&amp;#10;&amp;#9;gBitmap_class = make_globalref(env, &amp;#34;android/graphics/Bitmap&amp;#34;);&amp;#10;&amp;#9;......&amp;#10;&amp;#65373;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;定义在framework/base/jni/android/graphics/Graphics.cpp文件中&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文分析了从Java层到Native层分析了Bitmap对象的创建过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java外部类访问静态内部类的原因</title>
    <link href="http://gonggaofeng.me/2015/12/19/Java%E5%A4%96%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://gonggaofeng.me/2015/12/19/Java外部类访问静态内部类的原因/</id>
    <published>2015-12-19T08:27:02.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;本文分析了Java中外部类可以访问静态内部类的原因。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在Java中，我们可以在一个定义一个静态内部类，静态内部类和非静态内部类不同，它不会持有外部类的引用。我们将一个类定义成静态内部类和普通类的区别不大，个人认为有两个不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class文件名称不同。静态内部类的class文件名由其类名和其外部类名共同决定，具体是外部类的全名$内部类名.class&lt;/li&gt;
&lt;li&gt;静态内部类所属的外部类可以访问静态内部类的私有成员和私有方法。&lt;/li&gt;
&lt;li&gt;定义的位置不同。内部类嘛，是定义在某个类的内部。（废话）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然和普通类的区别不大，普通类的私有方法，我们在外部是无法访问的，但是为什么静态内部类的外部类可以访问其私有成员和私有方法？&lt;/p&gt;
&lt;p&gt;下面是一段简单的静态内部类的示例。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class TestMain &amp;#123;&amp;#10;    public int    mX = 0;&amp;#10;   &amp;#10;    public static void main(String[] args) &amp;#123;&amp;#10;        Child child = new Child();&amp;#10;        child.name = &amp;#34;kobe&amp;#34;;&amp;#10;        System.out.println(child.name);&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    public TestMain()&amp;#123;&amp;#10;    &amp;#125;&amp;#10;    public void test()&amp;#123;&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    public static class Child&amp;#123;&amp;#10;        private String name;&amp;#10;&amp;#10;        public Child()&amp;#123;&amp;#10;            this.name = name;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这段代码中，定义一个TestMain类，它有一个静态内部类Child，在main函数中创建了一个child的对象，并直接修改child的私有成员name的值为”kobe”，编译执行，一切ok。&lt;/p&gt;
&lt;p&gt;下面通过javap命令，查看TestMain的class文件，看看它的字节码是什么样子的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#62; javap -v com/test/TestMain.class&amp;#10;Classfile /Users/baidu/java_code/javavmtest/JavaCode/src/com/test/TestMain.class&amp;#10;  Last modified 2015-12-18; size 767 bytes&amp;#10;  MD5 checksum c923ce6a5bb70b704b1c5b0cc67e99d7&amp;#10;  Compiled from &amp;#34;TestMain.java&amp;#34;&amp;#10;public class com.test.TestMain&amp;#10;  SourceFile: &amp;#34;TestMain.java&amp;#34;&amp;#10;  InnerClasses:&amp;#10;       public static #12= #1 of #10; //Child=class com/test/TestMain$Child of class com/test/TestMain&amp;#10;  minor version: 0&amp;#10;  major version: 51&amp;#10;  flags: ACC_PUBLIC, ACC_SUPER&amp;#10;Constant pool:&amp;#10;   #1 = Class              #25            //  com/test/TestMain$Child&amp;#10;   #2 = Methodref          #1.#26         //  com/test/TestMain$Child.&amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;   #3 = String             #27            //  kobe&amp;#10;   #4 = Methodref          #1.#28         //  com/test/TestMain$Child.access$002:(Lcom/test/TestMain$Child;Ljava/lang/String;)Ljava/lang/String;&amp;#10;   #5 = Fieldref           #29.#30        //  java/lang/System.out:Ljava/io/PrintStream;&amp;#10;   #6 = Methodref          #1.#31         //  com/test/TestMain$Child.access$000:(Lcom/test/TestMain$Child;)Ljava/lang/String;&amp;#10;   #7 = Methodref          #32.#33        //  java/io/PrintStream.println:(Ljava/lang/String;)V&amp;#10;   #8 = Methodref          #11.#26        //  java/lang/Object.&amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;   #9 = Fieldref           #10.#34        //  com/test/TestMain.mX:I&amp;#10;  #10 = Class              #35            //  com/test/TestMain&amp;#10;  #11 = Class              #36            //  java/lang/Object&amp;#10;  #12 = Utf8               Child&amp;#10;  #13 = Utf8               InnerClasses&amp;#10;  #14 = Utf8               mX&amp;#10;  #15 = Utf8               I&amp;#10;  #16 = Utf8               main&amp;#10;  #17 = Utf8               ([Ljava/lang/String;)V&amp;#10;  #18 = Utf8               Code&amp;#10;  #19 = Utf8               LineNumberTable&amp;#10;  #20 = Utf8               &amp;#60;init&amp;#62;&amp;#10;  #21 = Utf8               ()V&amp;#10;  #22 = Utf8               test&amp;#10;  #23 = Utf8               SourceFile&amp;#10;  #24 = Utf8               TestMain.java&amp;#10;  #25 = Utf8               com/test/TestMain$Child&amp;#10;  #26 = NameAndType        #20:#21        //  &amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;  #27 = Utf8               kobe&amp;#10;  #28 = NameAndType        #37:#38        //  access$002:(Lcom/test/TestMain$Child;Ljava/lang/String;)Ljava/lang/String;&amp;#10;  #29 = Class              #39            //  java/lang/System&amp;#10;  #30 = NameAndType        #40:#41        //  out:Ljava/io/PrintStream;&amp;#10;  #31 = NameAndType        #42:#43        //  access$000:(Lcom/test/TestMain$Child;)Ljava/lang/String;&amp;#10;  #32 = Class              #44            //  java/io/PrintStream&amp;#10;  #33 = NameAndType        #45:#46        //  println:(Ljava/lang/String;)V&amp;#10;  #34 = NameAndType        #14:#15        //  mX:I&amp;#10;  #35 = Utf8               com/test/TestMain&amp;#10;  #36 = Utf8               java/lang/Object&amp;#10;  #37 = Utf8               access$002&amp;#10;  #38 = Utf8               (Lcom/test/TestMain$Child;Ljava/lang/String;)Ljava/lang/String;&amp;#10;  #39 = Utf8               java/lang/System&amp;#10;  #40 = Utf8               out&amp;#10;  #41 = Utf8               Ljava/io/PrintStream;&amp;#10;  #42 = Utf8               access$000&amp;#10;  #43 = Utf8               (Lcom/test/TestMain$Child;)Ljava/lang/String;&amp;#10;  #44 = Utf8               java/io/PrintStream&amp;#10;  #45 = Utf8               println&amp;#10;  #46 = Utf8               (Ljava/lang/String;)V&amp;#10;&amp;#123;&amp;#10;  public int mX;&amp;#10;    flags: ACC_PUBLIC&amp;#10;&amp;#10;  public static void main(java.lang.String[]);&amp;#10;    flags: ACC_PUBLIC, ACC_STATIC&amp;#10;    Code:&amp;#10;      stack=2, locals=2, args_size=1&amp;#10;         0: new           #1                  // class com/test/TestMain$Child&amp;#10;         3: dup&amp;#10;         4: invokespecial #2                  // Method com/test/TestMain$Child.&amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;         7: astore_1&amp;#10;         8: aload_1&amp;#10;         9: ldc           #3                  // String kobe&amp;#10;        11: invokestatic  #4                  // Method com/test/TestMain$Child.access$002:(Lcom/test/TestMain$Child;Ljava/lang/String;)Ljava/lang/String;&amp;#10;        14: pop&amp;#10;        15: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;&amp;#10;        18: aload_1&amp;#10;        19: invokestatic  #6                  // Method com/test/TestMain$Child.access$000:(Lcom/test/TestMain$Child;)Ljava/lang/String;&amp;#10;        22: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V&amp;#10;        25: return&amp;#10;      LineNumberTable:&amp;#10;        line 7: 0&amp;#10;        line 8: 8&amp;#10;        line 9: 15&amp;#10;        line 10: 25&amp;#10;&amp;#10;  public com.test.TestMain();&amp;#10;    flags: ACC_PUBLIC&amp;#10;    Code:&amp;#10;      stack=2, locals=1, args_size=1&amp;#10;         0: aload_0&amp;#10;         1: invokespecial #8                  // Method java/lang/Object.&amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;         4: aload_0&amp;#10;         5: iconst_0&amp;#10;         6: putfield      #9                  // Field mX:I&amp;#10;         9: return&amp;#10;      LineNumberTable:&amp;#10;        line 13: 0&amp;#10;        line 4: 4&amp;#10;        line 14: 9&amp;#10;&amp;#10;  public void test();&amp;#10;    flags: ACC_PUBLIC&amp;#10;    Code:&amp;#10;      stack=0, locals=1, args_size=1&amp;#10;         0: return&amp;#10;      LineNumberTable:&amp;#10;        line 16: 0&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第64行，开始执行main函数，从68行到70行是创建child对象，73行到74行将”kobe”赋值给了child的name成员，注意74行通过调用Child的静态方法access\$002完成给child.name赋值。access\$002并不是我们源码中写的，很明显这是Java编译器生成的代码。&lt;br&gt;下面是Child的字节码。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#62; javap -v com.test.TestMain\$Child&amp;#10;Classfile /Users/baidu/java_code/javavmtest/JavaCode/src/com/test/TestMain$Child.class&amp;#10;  Last modified 2015-12-18; size 557 bytes&amp;#10;  MD5 checksum 5f94b1089e491b12816272c9bc88bf32&amp;#10;  Compiled from &amp;#34;TestMain.java&amp;#34;&amp;#10;public class com.test.TestMain$Child&amp;#10;  SourceFile: &amp;#34;TestMain.java&amp;#34;&amp;#10;  InnerClasses:&amp;#10;       public static #12= #3 of #21; //Child=class com/test/TestMain$Child of class com/test/TestMain&amp;#10;  minor version: 0&amp;#10;  major version: 51&amp;#10;  flags: ACC_PUBLIC, ACC_SUPER&amp;#10;Constant pool:&amp;#10;   #1 = Fieldref           #3.#19         //  com/test/TestMain$Child.name:Ljava/lang/String;&amp;#10;   #2 = Methodref          #4.#20         //  java/lang/Object.&amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;   #3 = Class              #22            //  com/test/TestMain$Child&amp;#10;   #4 = Class              #23            //  java/lang/Object&amp;#10;   #5 = Utf8               name&amp;#10;   #6 = Utf8               Ljava/lang/String;&amp;#10;   #7 = Utf8               &amp;#60;init&amp;#62;&amp;#10;   #8 = Utf8               ()V&amp;#10;   #9 = Utf8               Code&amp;#10;  #10 = Utf8               LineNumberTable&amp;#10;  #11 = Utf8               access$002&amp;#10;  #12 = Utf8               Child&amp;#10;  #13 = Utf8               InnerClasses&amp;#10;  #14 = Utf8               (Lcom/test/TestMain$Child;Ljava/lang/String;)Ljava/lang/String;&amp;#10;  #15 = Utf8               access$000&amp;#10;  #16 = Utf8               (Lcom/test/TestMain$Child;)Ljava/lang/String;&amp;#10;  #17 = Utf8               SourceFile&amp;#10;  #18 = Utf8               TestMain.java&amp;#10;  #19 = NameAndType        #5:#6          //  name:Ljava/lang/String;&amp;#10;  #20 = NameAndType        #7:#8          //  &amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;  #21 = Class              #24            //  com/test/TestMain&amp;#10;  #22 = Utf8               com/test/TestMain$Child&amp;#10;  #23 = Utf8               java/lang/Object&amp;#10;  #24 = Utf8               com/test/TestMain&amp;#10;&amp;#123;&amp;#10;  public com.test.TestMain$Child();&amp;#10;    flags: ACC_PUBLIC&amp;#10;    Code:&amp;#10;      stack=2, locals=1, args_size=1&amp;#10;         0: aload_0&amp;#10;         1: invokespecial #2                  // Method java/lang/Object.&amp;#34;&amp;#60;init&amp;#62;&amp;#34;:()V&amp;#10;         4: aload_0&amp;#10;         5: aload_0&amp;#10;         6: getfield      #1                  // Field name:Ljava/lang/String;&amp;#10;         9: putfield      #1                  // Field name:Ljava/lang/String;&amp;#10;        12: return&amp;#10;      LineNumberTable:&amp;#10;        line 22: 0&amp;#10;        line 23: 4&amp;#10;        line 24: 12&amp;#10;&amp;#10;  static java.lang.String access$002(com.test.TestMain$Child, java.lang.String);&amp;#10;    flags: ACC_STATIC, ACC_SYNTHETIC&amp;#10;    Code:&amp;#10;      stack=3, locals=2, args_size=2&amp;#10;         0: aload_0&amp;#10;         1: aload_1&amp;#10;         2: dup_x1&amp;#10;         3: putfield      #1                  // Field name:Ljava/lang/String;&amp;#10;         6: areturn&amp;#10;      LineNumberTable:&amp;#10;        line 19: 0&amp;#10;&amp;#10;  static java.lang.String access$000(com.test.TestMain$Child);&amp;#10;    flags: ACC_STATIC, ACC_SYNTHETIC&amp;#10;    Code:&amp;#10;      stack=1, locals=1, args_size=1&amp;#10;         0: aload_0&amp;#10;         1: getfield      #1                  // Field name:Ljava/lang/String;&amp;#10;         4: areturn&amp;#10;      LineNumberTable:&amp;#10;        line 19: 0&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;很明显，编译器替我们生成了两个静态方法access$002和access$000，这两个方法很简单，access$002是修改name成员值的，access$000是返回name值得。flags：ACC_SYNTHETIC 说明由编译器产生,不存在于源代码中。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文分析了Java中外部类可以访问静态内部类的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://gonggaofeng.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>BASH 语法</title>
    <link href="http://gonggaofeng.me/2015/10/17/BASH-%E8%AF%AD%E6%B3%95/"/>
    <id>http://gonggaofeng.me/2015/10/17/BASH-语法/</id>
    <published>2015-10-17T14:53:25.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;简单介绍Bash的语法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;变量赋值&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=123&amp;#10;read name&amp;#10;b=$(ls /home) &amp;#25226;&amp;#21629;&amp;#20196;&amp;#30340;&amp;#25191;&amp;#34892;&amp;#32467;&amp;#26524;&amp;#36171;&amp;#20540;&amp;#32473;&amp;#21464;&amp;#37327;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用变量（前面用$）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo $a&amp;#10;let a=a+1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;系统变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$0 这个程序的执行名字&lt;/li&gt;
&lt;li&gt;$n 这个程序的第n个参数值，n=1…9&lt;/li&gt;
&lt;li&gt;$* 这个程序的所有参数&lt;/li&gt;
&lt;li&gt;$# 这个程序的参数个数&lt;/li&gt;
&lt;li&gt;$$ 这个程序的PID&lt;/li&gt;
&lt;li&gt;$! 执行上一个背景指令的PID&lt;/li&gt;
&lt;li&gt;$? 上一个指令的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;if语句&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if [ &amp;#34;22&amp;#34; -lt &amp;#34;33&amp;#34; ]&amp;#27880;&amp;#24847;&amp;#31354;&amp;#26684;&amp;#10;&amp;#10;then&amp;#10;&amp;#10;echo &amp;#34;22 less than 33&amp;#34;&amp;#10;&amp;#10;else&amp;#10;&amp;#10;echo &amp;#34;no&amp;#34;&amp;#10;&amp;#10;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;case语句&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/bash&amp;#10;&amp;#10;echo &amp;#34;enter a number&amp;#34;&amp;#10;&amp;#10;read ans&amp;#10;&amp;#10;case $ans in&amp;#10;&amp;#10;1)&amp;#10;&amp;#10;echo  &amp;#34;you numer is $ans&amp;#34;&amp;#10;&amp;#10;;;&amp;#10;&amp;#10;2)&amp;#10;&amp;#10;echo &amp;#34;you number is 2&amp;#34;&amp;#10;&amp;#10;;;&amp;#10;&amp;#10;[3-9])&amp;#10;&amp;#10;echo &amp;#34;you number is $ans&amp;#34;&amp;#10;&amp;#10;esac&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;比较运算符&lt;br&gt;|运算符        |描述        |示例|&lt;br&gt;|:————|:——    |:-|&lt;br&gt;|文件比较运算符|&lt;br&gt;|-e filename         |如果 filename 存在，则为真        |[ -e /var/log/syslog ]|&lt;br&gt;|-d filename         |如果 filename 为目录，则为真       | [ -d /tmp/mydir ]|&lt;br&gt;|-f filename         |如果 filename 为常规文件，则为真    |[ -f /usr/bin/grep ]|&lt;br&gt;|-L filename        | 如果 filename 为符号链接，则为真     |   [ -L /usr/bin/grep ]|&lt;br&gt;|-r filename        | 如果 filename 可读，则为真       | [ -r /var/log/syslog ]|&lt;br&gt;|-w filename         |如果 filename 可写，则为真       | [ -w /var/mytmp.txt ]|&lt;br&gt;|-x filename        | 如果 filename 可执行，则为真      |  [ -L /usr/bin/grep ]|&lt;br&gt;|filename1 -nt filename2   |      如果 filename1 比 filename2 新，则为真|        [ /tmp/install/etc/services -nt/etc/services ]|&lt;br&gt;|filename1 -ot filename2    |     如果 filename1 比 filename2 旧，则为真|        [ /boot/bzImage -otarch/i386/boot/bzImage ]|&lt;br&gt;|字符串比较运算符 （请注意引号的使用，这是防止空格扰乱代码的好方法）|&lt;br&gt;|-z string         |如果 string 长度为零，则为真       | [ -z “$myvar” ]|&lt;br&gt;|-n string        | 如果 string 长度非零，则为真      |  [ -n “$myvar” ]|&lt;br&gt;|string1 = string2        |如果 string1 与 string2 相同，则为真       | [ “$myvar” = “onetwo three” ]|&lt;br&gt;|string1 != string2        |如果 string1 与 string2 不同，则为真   |     [ “$myvar” !=”one two three” ]|&lt;br&gt;|算术比较运算符|&lt;br&gt;|num1 -eq num2       | 等于       | [ 3 -eq $mynum ]|&lt;br&gt;|num1 -ne num2       | 不等于      | [ 3 -ne $mynum ]|&lt;br&gt;|num1 -lt num2        |小于       |[ 3 -lt $mynum ]|&lt;br&gt;|num1 -le num2        |小于或等于  |     [ 3 -le $mynum ]|&lt;br&gt;|num1 -gt num2        |大于       |[ 3 -gt $mynum ]|&lt;br&gt;|num1 -ge num2        |大于或等于        |[ 3 -ge $mynum ]|&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;while语句&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ X=1&amp;#10;$ while [ $x -le 10 ]&amp;#10;do&amp;#10;&amp;#12288;&amp;#12288;echo hello X is $X&amp;#10;&amp;#12288;&amp;#12288;let X=X+1&amp;#10;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;bash中的for循环有几种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;for name [ in word ] ; do list ; done&lt;/li&gt;
&lt;li&gt;for (( expr1 ; expr2 ; expr3 )) ; do list ; done//注意有2层括号&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中list简单说就是一串由操作符（operator ；、&amp;amp;、&amp;amp;&amp;amp;、||）分隔开的管道（pipeline）序列，详情参看man bash&lt;/p&gt;
&lt;p&gt;各给出一个简单例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#10;for filename in `ls`&amp;#10;&amp;#10;do&amp;#10;&amp;#10;cat $filename&amp;#10;&amp;#10;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for((i=0; i&amp;#60;10; i++))&amp;#10;do&amp;#10;echo $i&amp;#10;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;条件变量替换&lt;/strong&gt;:&lt;br&gt;Bash Shell可以进行变量的条件替换,既只有某种条件发生时才进行替换,替换条件放在{}中.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;${value:-word}&lt;br&gt;当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值.&lt;/li&gt;
&lt;li&gt;${value:=word}&lt;br&gt;与前者类似,只是若变量未定义或者值为空时,在返回word的值的同时将word赋值给value&lt;/li&gt;
&lt;li&gt;${value:?message}&lt;br&gt;若变量以赋值的话,正常替换.否则将消息message送到标准错误输出(若此替换出现在Shell程序中,那么该程序将终止运行)&lt;/li&gt;
&lt;li&gt;${value:+word}&lt;br&gt;若变量以赋值的话,其值才用word替换,否则不进行任何替换&lt;/li&gt;
&lt;li&gt;&lt;p&gt;${value:offset}&lt;br&gt;${value:offset:length}&lt;br&gt;从变量中提取子串,这里offset和length可以是算术表达式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;${ #value}&lt;br&gt;变量的字符个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;${value#pattern}&lt;br&gt;${value##pattern}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;去掉value中与pattern相匹配的部分,条件是value的开头与pattern相匹配&lt;br&gt;#与##的区别在于一个是最短匹配模式,一个是最长匹配模式.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;${value%pattern}&lt;br&gt;${value%%pattern}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于(7)类似,只是是从value的尾部于pattern相匹配,%与%%的区别与#与##一样&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;${value/pattern/string}&lt;br&gt;${value//pattern/string}&lt;br&gt;进行变量内容的替换,把与pattern匹配的部分替换为string的内容,/与//的区别与上同&lt;br&gt;&lt;strong&gt;注意&lt;/strong&gt;:上述条件变量替换中,除(2)外,其余均不影响变量本身的值&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量的算术运算&lt;/strong&gt;&lt;br&gt;在Bash Shell中,只能进行两个整数间的运算,其结果仍为整数.要进行算术运算,需要使用let命令,语法为:&lt;br&gt;&lt;code&gt;let expr&lt;/code&gt;&lt;br&gt;expr 是一个包含项和操作符的表达式,项可以是一个变量或是一个整数常数,当使用整数常数时,其默认为十进制整数,用户可以用radio#number来指定其 它形式的整数,其中radio定义了整数是几进制表示的,number是该整数的值.若radio&amp;gt;10,那么数字字符可从0-9和A-Z.&lt;br&gt;在表达式中支持的操作符及其含义为:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+,-,*,/,% &amp;#21152;,&amp;#20943;,&amp;#20056;,&amp;#38500;,&amp;#21462;&amp;#27169;&amp;#10;\&amp;#62;&amp;#62;,&amp;#60;&amp;#60;,&amp;#38;,^,| &amp;#24038;&amp;#31227;,&amp;#21491;&amp;#31227;,&amp;#20301;&amp;#19982;,&amp;#20301;&amp;#24322;&amp;#25110;,&amp;#20301;&amp;#25110;&amp;#10;?: &amp;#19977;&amp;#20803;&amp;#36816;&amp;#31639;&amp;#31526;.&amp;#19982;C&amp;#35821;&amp;#35328;&amp;#20013;&amp;#30340;&amp;#23450;&amp;#20041;&amp;#19968;&amp;#33268;&amp;#10;~ &amp;#21462;&amp;#34917;&amp;#30721;&amp;#10;!,&amp;#62;=,&amp;#60;=,&amp;#62;,&amp;#60;,==,!=,&amp;#38;&amp;#38;,||&amp;#10;=,+=,-=,*=,/=,%=,&amp;#60;&amp;#60;=,&amp;#62;&amp;#62;=,&amp;#38;=,^=,|=&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表达式式中也可以使用括号.括号或运算优先级的定义与一般计算机语言中的相同.&lt;br&gt;let命令具有返回值.当计算结果(若有多个表达式时,以最后一个为准)为0时,返回值为1,否则为0.&lt;br&gt;当表达式中含有shell的特殊字符(如|)时,需要用引用符(‘或”)将其引用起来.&lt;br&gt;使用let时还需要注意的时,对于let x+y这样的式子,shell虽然计算了x+y的值但却将结果丢弃,若不想这样,可以使用let sum=x+y将x+y的结果保存在变量sum中&lt;br&gt;另外还可以使用((和))操作符取代let命令,而且这样的话,还可以省去对算术表达式的引用,如果想返回表达式的值,则需用$(())的格式&lt;/p&gt;
&lt;p&gt;使用set命令可以设置各种shell选项或者列出shell变量.单个选项设置常用的特性.&lt;br&gt;在某些选项之后-o参数将特殊特性打开.在某些选项之后使用+o参数将关闭某些特性,&lt;/p&gt;
&lt;p&gt;不带任何参数的set命令将显示shell的全部变量.除非遇到非法的选项,否则set总是返回ture.&lt;br&gt;当BASH shell被调用时,可以列出全部的选项.当前的选项集列在$-中.在option参数被处理后,其他的参数被赋值到位置参数中($1,$2,…,$n)&lt;/p&gt;
&lt;p&gt;set [–abefhkmnptuvxldCHP] [-o option name] [arguments …]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;选项说明&lt;/em&gt;&lt;br&gt;-a 自动向已经修改的变量或为导出后序命令的变量作出标志&lt;br&gt;-b 不是在原提示符之前,而是立即引发终止后台任务的状态表表&lt;br&gt;-e 如果命令带非零值返回,立即退出&lt;br&gt;-f 禁止带扩展名的路径&lt;br&gt;-h 定义函数时,定位和存储函数命令,当函数被执行时,通常查询函数命令&lt;br&gt;-k 所有的关键词参数,而不只是那些命令名前的关键词参数,被放在环境命令中&lt;br&gt;-m 监视器模式,启动任务控制.此选项默认支持系统shell交互.后台进程以单独的进程组运行,在每次完成任务时显示包含退出的状态行&lt;br&gt;-n 读取命令但不执行命令.通常监查shell脚本的句法错误.交互shell被忽略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-o option-name 选项名可以是下列之一:&lt;br&gt;选项 说明&lt;br&gt;allexport 同-a选项&lt;br&gt;braceexpand shell执行花括号扩展,在默认情况下起作用&lt;br&gt;emacs 使用emacs风格命令行编辑接口.除非shell以-noline-editing选项启动,否则当shell交互时,通过默认启动该选项&lt;br&gt;errexit 同-e选项&lt;br&gt;histexpand 同-H选项&lt;br&gt;ignoreeof 其结果是好像shell命令IGNOREEOF=10被执行&lt;br&gt;interactive 允许单词前带#号,以使得在交互shell中忽略命令行的全部字符&lt;br&gt;-commands&lt;br&gt;monitor 同-m选项&lt;br&gt;noclobber 同-C选项&lt;br&gt;noexec 同-n选项&lt;br&gt;noglob 同-f选项&lt;br&gt;nohash 同-d选项&lt;br&gt;notify 同-b选项&lt;br&gt;nounset 同-u选项&lt;br&gt;physical 同-p选项&lt;br&gt;posix 改变BASH属性以匹配标准,默认操作不同于POSIX1003.2标准&lt;br&gt;verbose 同-v选项&lt;br&gt;vi 使用vi风格的命令行编辑器&lt;br&gt;XTRACE 同-x选项,如果没有给出选项名,显示当前选项值&lt;br&gt;-p 打开特权模式(在此模式,$ENV文件被处理,不能从环境中继承shell函数.如果是有效用户ID而不是实用户组则自动启动.关闭此选项将使得有效用户和组IDs设置实用户和组IDs)&lt;br&gt;-t 在读取命令并执行之后退出&lt;br&gt;-u 当执行参数括展时,把非设置变量作为错误处理(如果扩展企图出现在非设置变量中,shell显示错误信息.如果不是交互式,则带非凌值退出)&lt;br&gt;-v 输入行被读取时,显示shell输入行&lt;br&gt;-x 在每个简单命令被扩展之后,显示PS4扩展值,之后是要执行的命令&lt;br&gt;-l 保存和恢复绑定在命令中的名称&lt;br&gt;-d 禁止执行查找散列命令(通常,命令被保存在散列表中,一旦被找到就不再继续查找)&lt;br&gt;-C 效果好像是执行了noclobber=shell命令&lt;br&gt;-H 使用!风格的历史替代(当shell交互时,在默认情况下,此选项有效)&lt;br&gt;-P 如果设置此参数,当执行改变目录命令cd时,不遵循符号链接,而是使用实际的目录&lt;br&gt;– 如果在选项后没有参数,不设置位置参数.否则,即使一些参数以a选项开始,也要把位置参数设置为argument&lt;br&gt;- 结束选项的信号,将引发其余的参数被赋值到位置参数中(-x和-v选项被关闭.如果没有argument,位置参数将保留未改变的参数)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数的使用&lt;br&gt;BASH 是一个相对简单的脚本语言，不过为了方便结构化的设计，BASH 中也提供了函数定义的功能。BASH 中的函数定义很简单，只要向下面这样写就可以了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function my_funcname &amp;#123;&amp;#10;&amp;#12288;code block&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;my_funcname() &amp;#123;&amp;#10;&amp;#12288;code block&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的第二种写法更接近于 C 语言中的写法。BASH 中要求函数的定义必须在函数使用之前，这是和 C 语言用头文件说明函数方法的不同。&lt;/p&gt;
&lt;p&gt;更 进一步的问题是如何给函数传递参数和获得返回值。BASH 中函数参数的定义并不需要在函数定义处就制定，而只需要在函数被调用时用 BASH 的保留变量 $1 $2 … 来引用就可以了；BASH 的返回值可以用 return 语句来指定返回一个特定的整数，如果没有 return 语句显式的返回一个返回值，则返回值就是该函数最后一条语句执行的结果（一般为 0，如果执行失败返回错误码）。函数的返回值在调用该函数的程序体中通过 $? 保留字来获得。下面我们就来看一个用函数来计算整数平方的例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;\#!/bin/bash&amp;#10;&amp;#10;square() &amp;#123;&amp;#10;&amp;#12288;let &amp;#34;res = $1 * $1&amp;#34;&amp;#10;&amp;#12288;return $res&amp;#10;&amp;#125;&amp;#10;&amp;#10;square $1&amp;#10;result=$?&amp;#10;echo $result&amp;#10;&amp;#10;exit 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍Bash的语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="bash" scheme="http://gonggaofeng.me/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>Resources的资源匹配优先级</title>
    <link href="http://gonggaofeng.me/2015/10/17/Resources%E7%9A%84%E8%B5%84%E6%BA%90%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://gonggaofeng.me/2015/10/17/Resources的资源匹配优先级/</id>
    <published>2015-10-17T14:39:21.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;记录Resource获取资源时不同设备的优先级。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;之前心里一直在打鼓，Android资源文件可以定义在不同分辨率，density，屏幕方向，最小宽度，当我们的程序需要找一个资源，但是他在多个文件下面都存在，那么Android系统的查找顺序是怎样的？最近在适配公司的项目，这些问题就深刻的站到面前了，抽时间查看了Android这部分的源代码，下面是ResTable_config类，此类是framework在native层的代码，用来记录系统的一些运行环境参数，比如屏幕方向，density，语言等等，需要详细了解的自行google。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool ResTable_config::match(const ResTable_config&amp;#38; settings) const &amp;#123;&amp;#10;    if (imsi != 0) &amp;#123;&amp;#10;        if (mcc != 0 &amp;#38;&amp;#38; mcc != settings.mcc) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        if (mnc != 0 &amp;#38;&amp;#38; mnc != settings.mnc) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    if (locale != 0) &amp;#123;&amp;#10;        // Don&amp;#39;t consider the script &amp;#38; variants when deciding matches.&amp;#10;        //&amp;#10;        // If we two configs differ only in their script or language, they&amp;#10;        // can be weeded out in the isMoreSpecificThan test.&amp;#10;        if (language[0] != 0&amp;#10;            &amp;#38;&amp;#38; (language[0] != settings.language[0]&amp;#10;                || language[1] != settings.language[1])) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        if (country[0] != 0&amp;#10;            &amp;#38;&amp;#38; (country[0] != settings.country[0]&amp;#10;                || country[1] != settings.country[1])) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (screenConfig != 0) &amp;#123;&amp;#10;        const int layoutDir = screenLayout&amp;#38;MASK_LAYOUTDIR;&amp;#10;        const int setLayoutDir = settings.screenLayout&amp;#38;MASK_LAYOUTDIR;&amp;#10;        if (layoutDir != 0 &amp;#38;&amp;#38; layoutDir != setLayoutDir) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        const int screenSize = screenLayout&amp;#38;MASK_SCREENSIZE;&amp;#10;        const int setScreenSize = settings.screenLayout&amp;#38;MASK_SCREENSIZE;&amp;#10;        // Any screen sizes for larger screens than the setting do not&amp;#10;        // match.&amp;#10;        if (screenSize != 0 &amp;#38;&amp;#38; screenSize &amp;#62; setScreenSize) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        const int screenLong = screenLayout&amp;#38;MASK_SCREENLONG;&amp;#10;        const int setScreenLong = settings.screenLayout&amp;#38;MASK_SCREENLONG;&amp;#10;        if (screenLong != 0 &amp;#38;&amp;#38; screenLong != setScreenLong) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        const int uiModeType = uiMode&amp;#38;MASK_UI_MODE_TYPE;&amp;#10;        const int setUiModeType = settings.uiMode&amp;#38;MASK_UI_MODE_TYPE;&amp;#10;        if (uiModeType != 0 &amp;#38;&amp;#38; uiModeType != setUiModeType) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        const int uiModeNight = uiMode&amp;#38;MASK_UI_MODE_NIGHT;&amp;#10;        const int setUiModeNight = settings.uiMode&amp;#38;MASK_UI_MODE_NIGHT;&amp;#10;        if (uiModeNight != 0 &amp;#38;&amp;#38; uiModeNight != setUiModeNight) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        if (smallestScreenWidthDp != 0&amp;#10;                &amp;#38;&amp;#38; smallestScreenWidthDp &amp;#62; settings.smallestScreenWidthDp) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    if (screenSizeDp != 0) &amp;#123;&amp;#10;        if (screenWidthDp != 0 &amp;#38;&amp;#38; screenWidthDp &amp;#62; settings.screenWidthDp) &amp;#123;&amp;#10;            //ALOGI(&amp;#34;Filtering out width %d in requested %d&amp;#34;, screenWidthDp, settings.screenWidthDp);&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        if (screenHeightDp != 0 &amp;#38;&amp;#38; screenHeightDp &amp;#62; settings.screenHeightDp) &amp;#123;&amp;#10;            //ALOGI(&amp;#34;Filtering out height %d in requested %d&amp;#34;, screenHeightDp, settings.screenHeightDp);&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    if (screenType != 0) &amp;#123;&amp;#10;        if (orientation != 0 &amp;#38;&amp;#38; orientation != settings.orientation) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        // density always matches - we can scale it.  See isBetterThan&amp;#10;        if (touchscreen != 0 &amp;#38;&amp;#38; touchscreen != settings.touchscreen) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    if (input != 0) &amp;#123;&amp;#10;        const int keysHidden = inputFlags&amp;#38;MASK_KEYSHIDDEN;&amp;#10;        const int setKeysHidden = settings.inputFlags&amp;#38;MASK_KEYSHIDDEN;&amp;#10;        if (keysHidden != 0 &amp;#38;&amp;#38; keysHidden != setKeysHidden) &amp;#123;&amp;#10;            // For compatibility, we count a request for KEYSHIDDEN_NO as also&amp;#10;            // matching the more recent KEYSHIDDEN_SOFT.  Basically&amp;#10;            // KEYSHIDDEN_NO means there is some kind of keyboard available.&amp;#10;            //ALOGI(&amp;#34;Matching keysHidden: have=%d, config=%d\n&amp;#34;, keysHidden, setKeysHidden);&amp;#10;            if (keysHidden != KEYSHIDDEN_NO || setKeysHidden != KEYSHIDDEN_SOFT) &amp;#123;&amp;#10;                //ALOGI(&amp;#34;No match!&amp;#34;);&amp;#10;                return false;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        const int navHidden = inputFlags&amp;#38;MASK_NAVHIDDEN;&amp;#10;        const int setNavHidden = settings.inputFlags&amp;#38;MASK_NAVHIDDEN;&amp;#10;        if (navHidden != 0 &amp;#38;&amp;#38; navHidden != setNavHidden) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        if (keyboard != 0 &amp;#38;&amp;#38; keyboard != settings.keyboard) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        if (navigation != 0 &amp;#38;&amp;#38; navigation != settings.navigation) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    if (screenSize != 0) &amp;#123;&amp;#10;        if (screenWidth != 0 &amp;#38;&amp;#38; screenWidth &amp;#62; settings.screenWidth) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        if (screenHeight != 0 &amp;#38;&amp;#38; screenHeight &amp;#62; settings.screenHeight) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    if (version != 0) &amp;#123;&amp;#10;        if (sdkVersion != 0 &amp;#38;&amp;#38; sdkVersion &amp;#62; settings.sdkVersion) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;        if (minorVersion != 0 &amp;#38;&amp;#38; minorVersion != settings.minorVersion) &amp;#123;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return true;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;代码位于framework/base/libs/androidfw/ResourceTypes.cpp&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先级&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IMSI&lt;/li&gt;
&lt;li&gt;语言&lt;/li&gt;
&lt;li&gt;国家&lt;/li&gt;
&lt;li&gt;UI mode（白天or黑夜）&lt;/li&gt;
&lt;li&gt;屏幕大小&lt;/li&gt;
&lt;li&gt;最小宽度DPI&lt;/li&gt;
&lt;li&gt;屏幕密度&lt;/li&gt;
&lt;li&gt;屏幕方向&lt;/li&gt;
&lt;li&gt;系统version&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;IMSI&lt;/em&gt;&lt;br&gt;由MCC、MNC、MSIN组成，其中MCC为移动国家号码，由3位数字组成，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 唯一地识别移动客户所属的国家，我国为460；MNC为网络id，由2位数字组成，
* 用于识别移动客户所归属的移动网络，中国移动为00，中国联通为01,中国电信为03；MSIN为移动客户识别码，采用等长11位数字构成。
* 唯一地识别国内GSM移动通信网中移动客户。所以要区分是移动还是联通，只需取得SIM卡中的MNC字段即可
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String imsi = telManager.getSubscriberId();&amp;#10;    if(imsi!=null)&amp;#123;&amp;#10;        if(imsi.startsWith(&amp;#34;46000&amp;#34;) || imsi.startsWith(&amp;#34;46002&amp;#34;))&amp;#123;//&amp;#22240;&amp;#20026;&amp;#31227;&amp;#21160;&amp;#32593;&amp;#32476;&amp;#32534;&amp;#21495;46000&amp;#19979;&amp;#30340;IMSI&amp;#24050;&amp;#32463;&amp;#29992;&amp;#23436;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#34394;&amp;#25311;&amp;#20102;&amp;#19968;&amp;#20010;46002&amp;#32534;&amp;#21495;&amp;#65292;134/159&amp;#21495;&amp;#27573;&amp;#20351;&amp;#29992;&amp;#20102;&amp;#27492;&amp;#32534;&amp;#21495;&amp;#10;        //&amp;#20013;&amp;#22269;&amp;#31227;&amp;#21160;&amp;#10;        &amp;#125;else if(imsi.startsWith(&amp;#34;46001&amp;#34;))&amp;#123;&amp;#10;        //&amp;#20013;&amp;#22269;&amp;#32852;&amp;#36890;&amp;#10;        &amp;#125;else if(imsi.startsWith(&amp;#34;46003&amp;#34;))&amp;#123;&amp;#10;        //&amp;#20013;&amp;#22269;&amp;#30005;&amp;#20449;&amp;#10;        &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;IMSI：国际移动用户识别码（唯一标识），IMSI = MCC + MNC + MSIN，其中MCC是指移动台国家代码（3 位，中国460），MNC是指移动网代码（2 位中国00），MSIN是指移动用户识别号码 (10 位 )&lt;br&gt;IMSI共有15位，其结构如下：&lt;br&gt;　　MCC+MNC+MSIN ，（MNC+MSIN=NMSI）&lt;br&gt;　　MCC：Mobile Country Code，移动国家码，MCC的资源由国际电联（ITU）统一分配和管理，唯一识别移动用户所属的国家，共3位，中国为460;&lt;br&gt;　　MNC:Mobile Network Code，移动网络码，共2位，中国移动TD系统使用00，中国联通GSM系统使用01，中国移动GSM系统使用02，中国电信CDMA系统使用03，一个典型的IMSI号码为460030912121001;&lt;br&gt;　　MSIN:Mobile Subscriber Identification Number共有10位，其结构如下：&lt;br&gt;　　09+M0M1M2M3+ABCD&lt;br&gt;　　其中的M0M1M2M3和MDN号码中的H0H1H2H3可存在对应关系，ABCD四位为自由分配。&lt;br&gt;　　可以看出IMSI在MSIN号码前加了MCC即NMSI，可以区别出每个用户的来自的国家，因此可以实现国际漫游。在同一个国家内，如果有多个移动网络运营商，可以通过MNC来进行区别.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;记录Resource获取资源时不同设备的优先级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Git Push Fails - fatal: The remote end hung up unexpectedly</title>
    <link href="http://gonggaofeng.me/2015/09/26/Git-Push-Fails-fatal-The-remote-end-hung-up-unexpectedly/"/>
    <id>http://gonggaofeng.me/2015/09/26/Git-Push-Fails-fatal-The-remote-end-hung-up-unexpectedly/</id>
    <published>2015-09-25T16:07:43.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;在用git push推送大文件时遇到此错误，作此记录。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Symptoms&lt;br&gt;When users try to run “git push” the following error message is shown:&lt;br&gt;$ git push&lt;br&gt;Counting objects: 2332669, done.&lt;br&gt;Delta compression using up to 16 threads.&lt;br&gt;Compressing objects: 100% (360818/360818), done.&lt;br&gt;error: RPC failed; result=22, HTTP code = 411&lt;br&gt;fatal: The remote end hung up unexpectedly&lt;br&gt;Writing objects: 100% (2332669/2332669), 483.30 MiB | 114.26 MiB/s, done.&lt;br&gt;Total 2332669 (delta 1949888), reused 2330461 (delta 1949349)&lt;br&gt;fatal: The remote end hung up unexpectedly&lt;br&gt;Cause&lt;br&gt;The “Smart HTTP” protocol in Git uses “Transfer-Encoding: chunked” in POST requests when it contains packed objects greater than 1MB in size.&lt;br&gt;Some proxy servers, like Nginx, do not support this transfer encoding by default, and the requests will be rejected before they get to Stash. Because of this, the Stash logs will not show any extra information.&lt;br&gt;Workaround&lt;br&gt;When pushing a large amount of data (initial push of a big repository, change with very big file(s)) may require a higher http.postBuffer setting on your git client (not the server). From &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-config.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.kernel.org/pub/software/scm/git/docs/git-config.html&lt;/a&gt;&lt;br&gt;http.postBuffer&lt;br&gt;Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.&lt;br&gt;Configuration on your reverse proxy. Usually ngnix the parameter client_max_body_size is a blocker. The reverse proxy may also have a connection timeout that’s closing the connection (e.g. TimeOut or ProxyTimeout in apache, proxy_read_timeout in ngnix). Try bypassing the proxy by pushing directly to Stash IP:port. If this works, it’s highly likely that the proxy server is causing the early disconnect and needs to be tuned.&lt;br&gt;User is using an outbound proxy on his machine that is causing the issue.&lt;br&gt;Resolution&lt;br&gt;Increase the Git buffer size to the largest individual file size of your repo:&lt;br&gt;git config –global http.postBuffer 157286400&lt;br&gt;Refer to the resolution of Git push fails - client intended to send too large chunked body for ngnix reverse proxy configuration. Increase this parameter to the largest individual file size of your repo.&lt;br&gt;Bypass the outbound proxy as explained on Can’t clone or pull due to a git outbound proxy&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在用git push推送大文件时遇到此错误，作此记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://gonggaofeng.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio Mac&amp;Windows快捷键</title>
    <link href="http://gonggaofeng.me/2015/09/24/Android-Studio-Mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://gonggaofeng.me/2015/09/24/Android-Studio-Mac快捷键/</id>
    <published>2015-09-24T04:25:21.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;AS的Mac和Window的快捷键纪录。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;代码高亮&lt;/p&gt;
&lt;p&gt;OSX:Shift + Cmd + F7&lt;/p&gt;
&lt;p&gt;Win/Linux:Alt + J&lt;/p&gt;
&lt;p&gt;代码高亮向上查找&lt;/p&gt;
&lt;p&gt;OSX:Shift + Cmd + G&lt;/p&gt;
&lt;p&gt;Win/Linux:Shift + F3&lt;/p&gt;
&lt;p&gt;代码高亮向下查找&lt;/p&gt;
&lt;p&gt;OSX:Cmd + G&lt;/p&gt;
&lt;p&gt;Win/Linux:F3&lt;/p&gt;
&lt;p&gt;文件方法结构&lt;/p&gt;
&lt;p&gt;OSX:Cmd + F12&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + F12&lt;/p&gt;
&lt;p&gt;查找调用的位置&lt;/p&gt;
&lt;p&gt;OSX/Win/Linux:Ctrl + Alt + H&lt;/p&gt;
&lt;p&gt;快速查找定义&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Space&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Shift + I&lt;/p&gt;
&lt;p&gt;折叠展开代码块&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Plus,Minus&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Shift + Plus/Minus&lt;/p&gt;
&lt;p&gt;折叠展开全部代码块&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Shift + Plus,Minus&lt;/p&gt;
&lt;p&gt;Win/Linux:&lt;/p&gt;
&lt;p&gt;添加书签&lt;/p&gt;
&lt;p&gt;OSX:F3&lt;/p&gt;
&lt;p&gt;Win/Linux:F11&lt;/p&gt;
&lt;p&gt;添加书签标识&lt;/p&gt;
&lt;p&gt;OSX:Alt + F3&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + F11&lt;/p&gt;
&lt;p&gt;显示书签&lt;/p&gt;
&lt;p&gt;OSX:Cmd + F3&lt;/p&gt;
&lt;p&gt;Win/Linux:Shift + F11&lt;/p&gt;
&lt;p&gt;查找动作&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Shift + A&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Shift + A&lt;/p&gt;
&lt;p&gt;上下移动代码&lt;/p&gt;
&lt;p&gt;OXS/Win/Linux:Alt + Shift + Up/Down&lt;/p&gt;
&lt;p&gt;删除行&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Delete&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Y&lt;/p&gt;
&lt;p&gt;快捷向下复制行&lt;/p&gt;
&lt;p&gt;OSX:Cmd + D&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + D&lt;/p&gt;
&lt;p&gt;扩大缩小选中范围&lt;/p&gt;
&lt;p&gt;OSX:Alt + Up/Down&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + W/Ctrl + Shift + W&lt;/p&gt;
&lt;p&gt;快捷生成结构体&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Alt + T&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Alt + T&lt;/p&gt;
&lt;p&gt;快捷覆写方法&lt;/p&gt;
&lt;p&gt;OSX:Ctrl + O&lt;/p&gt;
&lt;p&gt;Win/Linux:&lt;/p&gt;
&lt;p&gt;快捷定位到行首/尾&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Left/Right&lt;/p&gt;
&lt;p&gt;按照模板生成代码&lt;/p&gt;
&lt;p&gt;OSX:Cmd + J&lt;/p&gt;
&lt;p&gt;Win/Linux: Ctrl + J&lt;/p&gt;
&lt;p&gt;或者 .&lt;/p&gt;
&lt;p&gt;注释代码(//)&lt;/p&gt;
&lt;p&gt;OSX:Cmd + /&lt;/p&gt;
&lt;p&gt;Win/Linux:&lt;/p&gt;
&lt;p&gt;注释代码(/**/)&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Alt + /&lt;/p&gt;
&lt;p&gt;Win/Linux:&lt;/p&gt;
&lt;p&gt;格式化代码&lt;/p&gt;
&lt;p&gt;OSX:Cmd + Alt + L&lt;/p&gt;
&lt;p&gt;Win/Linux:&lt;/p&gt;
&lt;p&gt;快捷选择&lt;/p&gt;
&lt;p&gt;OSX:Alt + F1&lt;/p&gt;
&lt;p&gt;Win/Linux:Alt + F1&lt;/p&gt;
&lt;p&gt;快捷移动&lt;/p&gt;
&lt;p&gt;OSX:Ctrl + Up/Down&lt;/p&gt;
&lt;p&gt;Win/Linux:&lt;/p&gt;
&lt;p&gt;快捷退至上一行末尾&lt;/p&gt;
&lt;p&gt;OSX:Ctrl + Shift + J&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Shift + J&lt;/p&gt;
&lt;p&gt;快捷最近打开&lt;/p&gt;
&lt;p&gt;OSX:Cmd + E&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + E&lt;/p&gt;
&lt;p&gt;清楚无效引用&lt;/p&gt;
&lt;p&gt;Alt + Control + O&lt;/p&gt;
&lt;p&gt;Win/Linux:Alt + Control + O&lt;/p&gt;
&lt;p&gt;代码补全&lt;/p&gt;
&lt;p&gt;Cmd + Shift + Enter&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + Shift + Enter&lt;/p&gt;
&lt;p&gt;提示错误解决方案&lt;/p&gt;
&lt;p&gt;Alt + Enter&lt;/p&gt;
&lt;p&gt;Win/Linux:Alt + Enter&lt;/p&gt;
&lt;p&gt;提示参数类型&lt;/p&gt;
&lt;p&gt;Cmd + P&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + P&lt;/p&gt;
&lt;p&gt;查找+替换&lt;/p&gt;
&lt;p&gt;Cmd + R&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + R&lt;/p&gt;
&lt;p&gt;查找&lt;/p&gt;
&lt;p&gt;Cmd + F&lt;/p&gt;
&lt;p&gt;Win/Linux:Ctrl + F&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;AS的Mac和Window的快捷键纪录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>国内镜像快速下载Android源码</title>
    <link href="http://gonggaofeng.me/2015/09/12/%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDAndroid%E6%BA%90%E7%A0%81/"/>
    <id>http://gonggaofeng.me/2015/09/12/国内镜像快速下载Android源码/</id>
    <published>2015-09-12T15:27:02.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;实用国内镜像下载Android系统源代码。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;由于google官方的下载源不能访问，原因大家都懂得，vpn小水管对于下载Android源代码只能呵呵了。幸好清华大学镜像为我们提供了Android源码的下载源，速度杠杠的，所以心动地立即搞起来。&lt;br&gt;&lt;a href=&quot;https://wiki.tuna.tsinghua.edu.cn/MirrorUsage/android&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;清华大学镜像源官方介绍&lt;/a&gt;&lt;br&gt;–下载环境&lt;br&gt;我使用的设备是Macbook Pro＋OS X10.10.5。&lt;br&gt;1.首先创建区分大小写的磁盘映像，大小30G，因为源码的编译需要大小写敏感的文件系统，而mac默认的文件系统是大小写不敏感的。创建方法：&lt;br&gt;应用程序-&amp;gt;实用工具－&amp;gt;磁盘工具-&amp;gt;文件－&amp;gt;新建-&amp;gt;空白磁盘映像&lt;br&gt;&lt;img src=&quot;http://7xk9c0.com1.z0.glb.clouddn.com/gaofeng-blog屏幕快照%202015-09-12%20下午11.41.05.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;2.安装XCode。&lt;br&gt;3.安装MacPort&lt;br&gt;4.从MacPorts安装make, git, and GPG packages：&lt;br&gt;$ POSIXLY_CORRECT=1 sudo port install gmake libsdl git-core gnupg&lt;br&gt;5安装Git Repo：&lt;br&gt;$ mkdir ~/bin&lt;br&gt;$ PATH=~/bin:$PATH&lt;br&gt;6.curl &lt;a href=&quot;https://storage.googleapis.com/git-repo-downloads/repo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://storage.googleapis.com/git-repo-downloads/repo&lt;/a&gt; &amp;gt; ~/bin/repo（需要科学上网），科学不了的可以尝试下面的命令：&lt;br&gt;curl “&lt;a href=&quot;http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo&lt;/a&gt;“ &amp;gt; ~/bin/repo&lt;br&gt;$ chmod a+x ~/bin/repo&lt;br&gt;初始化Git Repo进入开始时挂载的镜像硬盘，建立一个工作目录：&lt;br&gt;$ cd /Volumes/android_source&lt;br&gt;$ mkdir ANDROID_SOURCE/&lt;br&gt;$ cd ANDROID_SOURCE/&lt;br&gt;repo init -u git://aosp.tuna.tsinghua.edu.cn/android/platform/manifest -b android-5.1.1_r3&lt;br&gt;repo sync&lt;br&gt;或者&lt;br&gt;repo sync -j4（四个线程并发下载）&lt;br&gt;接下来就等待吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;实用国内镜像下载Android系统源代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ViewGroup的OnInterceptTouchEvent方法的调用特点分析</title>
    <link href="http://gonggaofeng.me/2015/07/09/ViewGroup%E7%9A%84OnInterceptTouchEvent%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E7%89%B9%E7%82%B9%E5%88%86%E6%9E%90/"/>
    <id>http://gonggaofeng.me/2015/07/09/ViewGroup的OnInterceptTouchEvent方法的调用特点分析/</id>
    <published>2015-07-09T04:18:15.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;从源码角度谈就ViewGroup的onInterceptTouchEvent方法的调用流程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;当ViewGroup的childView的onTouchEvent方法返回true时表示该childView可以接受MotionEvent事件， 此时在ViewGroup上的有MotionEvent时间发生时，每次都会调用OnInterceptTouchEvent方法。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当ViewGroup的childView的onTouchEvent方法返回false时表示该childView不接受MotionEvent事件， 如果ViewGroup的onTouchEvent方法返回true表示ViewGroup可以接受MotionEvent方法，此后onInterceptTouchEvent方法不会再调用，直接调用ViewGroup 的onTouchEvent方法。&lt;/p&gt;
&lt;p&gt;  一个MotionEvent事件由一个ACTION_DOWN事件,若干个ACTION_MOVE事件,一个ACTION_UP事件组成。当一个MotionEvent事件发生时，ViewGroup接到MotionEvent的上述的事件后，ViewGroup调用自己的dispatchTouchEvent方法来向其childView以及自身来分配MotionEvent的事件。来看ViewGroup的dispatchTouchEvent方法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public boolean dispatchTouchEvent(MotionEvent ev) &amp;#123;&amp;#10;        if (mInputEventConsistencyVerifier != null) &amp;#123;&amp;#10;            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        boolean handled = false;&amp;#10;        if (onFilterTouchEventForSecurity(ev)) &amp;#123;&amp;#10;            final int action = ev.getAction();&amp;#10;            final int actionMasked = action &amp;#38; MotionEvent.ACTION_MASK;&amp;#10;&amp;#10;            // Handle an initial down.&amp;#10;            /**ACTION_DOWN&amp;#34920;&amp;#31034;&amp;#26032;&amp;#30340;&amp;#20107;&amp;#20214;&amp;#21040;&amp;#26469;&amp;#65292;&amp;#21462;&amp;#28040;&amp;#24182;&amp;#19988;&amp;#28165;&amp;#26970;&amp;#20043;&amp;#21069;&amp;#20445;&amp;#30041;&amp;#30340;TouchTarget&amp;#65292;&amp;#24182;&amp;#19988;&amp;#37325;&amp;#32622;touchState&amp;#65292;&amp;#10;            &amp;#65290;TouchTarget&amp;#34920;&amp;#31034;&amp;#25509;&amp;#21463;MotionEvent&amp;#30340;childView&amp;#12290;&amp;#10;            **/&amp;#10;            if (actionMasked == MotionEvent.ACTION_DOWN) &amp;#123;&amp;#10;                // Throw away all previous state when starting a new touch gesture.&amp;#10;                // The framework may have dropped the up or cancel event for the previous gesture&amp;#10;                // due to an app switch, ANR, or some other state change.&amp;#10;                cancelAndClearTouchTargets(ev);&amp;#10;                resetTouchState();&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            // Check for interception.&amp;#10;            final boolean intercepted;&amp;#10;            /*&amp;#10;            *&amp;#19979;&amp;#38754;&amp;#30340;&amp;#21028;&amp;#26029;&amp;#34920;&amp;#31034;&amp;#24403;ACTION_DOWN&amp;#20107;&amp;#20214;&amp;#21040;&amp;#26469;&amp;#26102;&amp;#65292;&amp;#38656;&amp;#35201;&amp;#35843;&amp;#29992;OnInterceptTouchEvent&amp;#26041;&amp;#27861;&amp;#12290;&amp;#21516;&amp;#26102;&amp;#22914;&amp;#26524;&amp;#9;&amp;#9;&amp;#9;&amp;#9; *mFirstTouchTarget&amp;#19981;&amp;#20026;null&amp;#26102;&amp;#38656;&amp;#35201;&amp;#35843;&amp;#29992;OnInterceptTouchEvent&amp;#26041;&amp;#27861;&amp;#65292;mFirstTouchTarget&amp;#19981;&amp;#20026;null&amp;#10;            *&amp;#34920;&amp;#31034;childView&amp;#21487;&amp;#20197;&amp;#25509;&amp;#21463;MotionEvent&amp;#20107;&amp;#20214;&amp;#65292;&amp;#21363;childView&amp;#20013;&amp;#26377;onTouchEvent&amp;#36820;&amp;#22238;true&amp;#30340;&amp;#12290;&amp;#24403;ACTION_DOWN&amp;#20107;&amp;#10;            *&amp;#20214;&amp;#21040;&amp;#26469;&amp;#26102;&amp;#65292;mFirstTouchEvent&amp;#24517;&amp;#28982;&amp;#20026;null&amp;#12290;&amp;#24403;MotionEvent&amp;#21518;&amp;#38754;&amp;#30340;ACTION_MOVE&amp;#21644;ACTION_UP&amp;#20107;&amp;#20214;&amp;#21040;&amp;#26469;&amp;#26102;&amp;#65292;&amp;#10;            *mFirstTouchTarget&amp;#20026;null&amp;#65288;childView&amp;#37117;&amp;#19981;&amp;#25509;&amp;#21463;MotionEvent&amp;#20107;&amp;#20214;&amp;#65289;,&amp;#23601;&amp;#20250;&amp;#36827;&amp;#20837;else&amp;#35821;&amp;#21477;&amp;#65292;&amp;#19981;&amp;#20250;&amp;#20877;&amp;#35843;&amp;#29992;&amp;#10;            *onInterceptTouchEvent&amp;#26041;&amp;#27861;&amp;#12290;&amp;#10;            */&amp;#10;            if (actionMasked == MotionEvent.ACTION_DOWN&amp;#10;                    || mFirstTouchTarget != null) &amp;#123;&amp;#10;                //disallowIntercept&amp;#21487;&amp;#20197;&amp;#35753;childView&amp;#36890;&amp;#36807;&amp;#35843;&amp;#29992;requestDisallowInterceptTouchEvent&amp;#26041;&amp;#27861;&amp;#26469;&amp;#35774;&amp;#32622;&amp;#10;                final boolean disallowIntercept = (mGroupFlags &amp;#38; FLAG_DISALLOW_INTERCEPT) != 0;&amp;#10;                if (!disallowIntercept) &amp;#123;&amp;#10;                    intercepted = onInterceptTouchEvent(ev);&amp;#10;                    ev.setAction(action); // restore action in case it was changed&amp;#10;                &amp;#125; else &amp;#123;&amp;#10;                    intercepted = false;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125; else &amp;#123;&amp;#10;                // There are no touch targets and this action is not an initial down&amp;#10;                // so this view group continues to intercept touches.&amp;#10;                intercepted = true;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            // Check for cancelation.&amp;#10;            final boolean canceled = resetCancelNextUpFlag(this)&amp;#10;                    || actionMasked == MotionEvent.ACTION_CANCEL;&amp;#10;&amp;#10;            // Update list of touch targets for pointer down, if needed.&amp;#10;            final boolean split = (mGroupFlags &amp;#38; FLAG_SPLIT_MOTION_EVENTS) != 0;&amp;#10;            TouchTarget newTouchTarget = null;&amp;#10;            boolean alreadyDispatchedToNewTouchTarget = false;&amp;#10;            /*&amp;#10;            *&amp;#24403;&amp;#19978;&amp;#38754;&amp;#30340;intercepted&amp;#20026;false&amp;#65292;&amp;#24182;&amp;#19988;canceled&amp;#20026;false&amp;#26102;&amp;#65292;&amp;#23601;&amp;#35201;&amp;#21521;childview&amp;#20256;&amp;#36882;MotionEvent&amp;#20107;&amp;#20214;&amp;#20102;&amp;#12290;&amp;#10;            *&amp;#10;            *&amp;#24403;ACTION_DOWN&amp;#20107;&amp;#20214;&amp;#21040;&amp;#26469;&amp;#26102;&amp;#65292;&amp;#20877;&amp;#19978;&amp;#38754;&amp;#35843;&amp;#29992;&amp;#20102;onInterceptTouchEvent&amp;#26041;&amp;#27861;&amp;#65292;&amp;#35813;&amp;#26041;&amp;#27861;&amp;#40664;&amp;#35748;&amp;#36820;&amp;#22238;false&amp;#65292;&amp;#24403;&amp;#35813;&amp;#26041;&amp;#27861;&amp;#10;            *&amp;#36820;&amp;#22238;false&amp;#65292;&amp;#21363;intercepted&amp;#20026;false&amp;#65288;resetCancelNextUpFlag(this)&amp;#22823;&amp;#22810;&amp;#24773;&amp;#20917;&amp;#19979;&amp;#25918;&amp;#22238;false&amp;#65292;&amp;#25152;&amp;#20197;&amp;#10;            *canceled&amp;#32943;&amp;#23450;&amp;#20026;false&amp;#65292;&amp;#22240;&amp;#20026;&amp;#26159;ACTION_DOWN&amp;#65289;,if&amp;#35821;&amp;#21477;&amp;#28385;&amp;#36275;&amp;#12290;&amp;#10;            */&amp;#10;            if (!canceled &amp;#38;&amp;#38; !intercepted) &amp;#123;&amp;#10;            &amp;#9;  /*&amp;#10;            &amp;#9;  *&amp;#24403;ACTION_DOWN&amp;#25110;&amp;#32773;ACTION_MOVE&amp;#25110;&amp;#32773;ACTION_POINTER_DOWN&amp;#21516;&amp;#26102;ViewGroup&amp;#21487;&amp;#20197;&amp;#35762;&amp;#19968;&amp;#20010;&amp;#20107;&amp;#20214;&amp;#20998;&amp;#32473;&amp;#22810;&amp;#20010;&amp;#10;            &amp;#9;  *childView&amp;#26102;&amp;#65292;&amp;#36827;&amp;#20837;if&amp;#35821;&amp;#21477;&amp;#12290;&amp;#10;            &amp;#9;  */&amp;#10;                if (actionMasked == MotionEvent.ACTION_DOWN&amp;#10;                        || (split &amp;#38;&amp;#38; actionMasked == MotionEvent.ACTION_POINTER_DOWN)&amp;#10;                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &amp;#123;&amp;#10;                    final int actionIndex = ev.getActionIndex(); // always 0 for down&amp;#10;                    final int idBitsToAssign = split ? 1 &amp;#60;&amp;#60; ev.getPointerId(actionIndex)&amp;#10;                            : TouchTarget.ALL_POINTER_IDS;&amp;#10;&amp;#10;                    // Clean up earlier touch targets for this pointer id in case they&amp;#10;                    // have become out of sync.&amp;#10;                    removePointersFromTouchTargets(idBitsToAssign);&amp;#10;                    /*&amp;#10;                    *&amp;#19979;&amp;#38754;&amp;#25214;&amp;#20986;MotionEvent&amp;#23545;&amp;#24212;&amp;#30340;&amp;#37027;&amp;#20010;childView&amp;#10;                    */&amp;#10;                    final int childrenCount = mChildrenCount;&amp;#10;                    if (newTouchTarget == null &amp;#38;&amp;#38; childrenCount != 0) &amp;#123;&amp;#10;                        final float x = ev.getX(actionIndex);&amp;#10;                        final float y = ev.getY(actionIndex);&amp;#10;                        // Find a child that can receive the event.&amp;#10;                        // Scan children from front to back.&amp;#10;                        final ArrayList&amp;#60;View&amp;#62; preorderedList = buildOrderedChildList();&amp;#10;                        final boolean customOrder = preorderedList == null&amp;#10;                                &amp;#38;&amp;#38; isChildrenDrawingOrderEnabled();&amp;#10;                        final View[] children = mChildren;&amp;#10;                        for (int i = childrenCount - 1; i &amp;#62;= 0; i--) &amp;#123;&amp;#10;                            final int childIndex = customOrder&amp;#10;                                    ? getChildDrawingOrder(childrenCount, i) : i;&amp;#10;                            final View child = (preorderedList == null)&amp;#10;                                    ? children[childIndex] : preorderedList.get(childIndex);&amp;#10;                            /*&amp;#10;                            *&amp;#24403;&amp;#35813;childView&amp;#19981;&amp;#26159;&amp;#21487;&amp;#35265;&amp;#65292;&amp;#25110;&amp;#32773;childView&amp;#30340;&amp;#21306;&amp;#22495;&amp;#19981;&amp;#21253;&amp;#21547;MotionEvent&amp;#30340;&amp;#20301;&amp;#32622;&amp;#65292;&amp;#21017;&amp;#32487;&amp;#32493;&amp;#36941;&amp;#21382;&amp;#10;                            */&amp;#10;                            if (!canViewReceivePointerEvents(child)&amp;#10;                                    || !isTransformedTouchPointInView(x, y, child, null)) &amp;#123;&amp;#10;                                continue;&amp;#10;                            &amp;#125;&amp;#10;                            //&amp;#33719;&amp;#21462;&amp;#35813;childView&amp;#23545;&amp;#24212;&amp;#30340;touchTarget&amp;#10;                            newTouchTarget = getTouchTarget(child);&amp;#10;                            //&amp;#22312;ACTION_DOWN&amp;#38454;&amp;#27573;&amp;#65292;newTouchTarget&amp;#32943;&amp;#23450;&amp;#20026;null&amp;#65292;&amp;#36825;&amp;#37324;&amp;#22312;ACTION_POINTER_DOWN&amp;#38454;&amp;#27573;&amp;#36827;&amp;#20837;if&amp;#26465;&amp;#20214;&amp;#10;                            if (newTouchTarget != null) &amp;#123;&amp;#10;                                // Child is already receiving touch within its bounds.&amp;#10;                                // Give it the new pointer in addition to the ones it is handling.&amp;#10;                                newTouchTarget.pointerIdBits |= idBitsToAssign;&amp;#10;                                break;&amp;#10;                            &amp;#125;&amp;#10;                            &amp;#10;                            resetCancelNextUpFlag(child);&amp;#10;                            /*&amp;#10;                            *dispatchTransformedTouchEvent&amp;#26041;&amp;#27861;&amp;#20013;&amp;#20250;&amp;#35843;&amp;#29992;child&amp;#30340;dispatchTouchEvent&amp;#26041;&amp;#27861;&amp;#12290;&amp;#10;                            *&amp;#22914;&amp;#26524;child&amp;#19981;&amp;#26159;ViewGroup&amp;#65292;&amp;#21017;child&amp;#30340;dispatchTouchEvent&amp;#35843;&amp;#29992;&amp;#20102;OnTouchListener&amp;#10;                            *&amp;#30340;onTouch&amp;#26041;&amp;#27861;&amp;#65292;&amp;#22914;&amp;#26524;onTouch&amp;#36820;&amp;#22238;false&amp;#65292;&amp;#35843;&amp;#29992;onTouchEvent&amp;#26041;&amp;#27861;&amp;#12290;&amp;#10;                            *&amp;#22914;&amp;#26524;dispatchTransformedTouchEven&amp;#36820;&amp;#22238;true&amp;#65292;&amp;#35828;&amp;#26126;child&amp;#25509;&amp;#21463;Touch&amp;#20107;&amp;#20214;&amp;#12290;&amp;#10;                            */&amp;#10;                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &amp;#123;&amp;#10;                                // Child wants to receive touch within its bounds.&amp;#10;                                mLastTouchDownTime = ev.getDownTime();&amp;#10;                                if (preorderedList != null) &amp;#123;&amp;#10;                                    // childIndex points into presorted list, find original index&amp;#10;                                    for (int j = 0; j &amp;#60; childrenCount; j++) &amp;#123;&amp;#10;                                        if (children[childIndex] == mChildren[j]) &amp;#123;&amp;#10;                                            mLastTouchDownIndex = j;&amp;#10;                                            break;&amp;#10;                                        &amp;#125;&amp;#10;                                    &amp;#125;&amp;#10;                                &amp;#125; else &amp;#123;&amp;#10;                                    mLastTouchDownIndex = childIndex;&amp;#10;                                &amp;#125;&amp;#10;                                mLastTouchDownX = ev.getX();&amp;#10;                                mLastTouchDownY = ev.getY();&amp;#10;                                /*&amp;#10;                                *&amp;#35843;&amp;#29992;addTouchTarget&amp;#21518;&amp;#65292;mFirstTouchTarget&amp;#23601;&amp;#19981;&amp;#20026;null&amp;#20102;&amp;#12290;&amp;#10;                                */&amp;#10;                                newTouchTarget = addTouchTarget(child, idBitsToAssign);&amp;#10;                                alreadyDispatchedToNewTouchTarget = true;&amp;#10;                                break;&amp;#10;                            &amp;#125;&amp;#10;                        &amp;#125;&amp;#10;                        if (preorderedList != null) preorderedList.clear();&amp;#10;                    &amp;#125;&amp;#10;&amp;#10;                    if (newTouchTarget == null &amp;#38;&amp;#38; mFirstTouchTarget != null) &amp;#123;&amp;#10;                        // Did not find a child to receive the event.&amp;#10;                        // Assign the pointer to the least recently added target.&amp;#10;                        newTouchTarget = mFirstTouchTarget;&amp;#10;                        while (newTouchTarget.next != null) &amp;#123;&amp;#10;                            newTouchTarget = newTouchTarget.next;&amp;#10;                        &amp;#125;&amp;#10;                        newTouchTarget.pointerIdBits |= idBitsToAssign;&amp;#10;                    &amp;#125;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;&amp;#9;&amp;#9;&amp;#9;/*&amp;#10;&amp;#9;&amp;#9;    *&amp;#27809;&amp;#26377;child&amp;#21487;&amp;#20197;&amp;#25509;&amp;#21463;MotionEvent, &amp;#35753;&amp;#33258;&amp;#24049;&amp;#26469;&amp;#12290;&amp;#10;&amp;#9;&amp;#9;&amp;#9;*/&amp;#10;            // Dispatch to touch targets.&amp;#10;            if (mFirstTouchTarget == null) &amp;#123;&amp;#10;                // No touch targets so treat this as an ordinary view.&amp;#10;                handled = dispatchTransformedTouchEvent(ev, canceled, null,&amp;#10;                        TouchTarget.ALL_POINTER_IDS);&amp;#10;            &amp;#125; else &amp;#123;&amp;#10;                // Dispatch to touch targets, excluding the new touch target if we already&amp;#10;                // dispatched to it.  Cancel touch targets if necessary.&amp;#10;                TouchTarget predecessor = null;&amp;#10;                TouchTarget target = mFirstTouchTarget;&amp;#10;                while (target != null) &amp;#123;&amp;#10;                    final TouchTarget next = target.next;&amp;#10;                    //&amp;#19979;&amp;#38754;&amp;#30340;if&amp;#35821;&amp;#21477;&amp;#34920;&amp;#31034;&amp;#22312;ACTION_DOWN&amp;#38454;&amp;#27573;&amp;#24050;&amp;#32463;&amp;#22788;&amp;#29702;&amp;#36807;&amp;#20102;&amp;#23601;&amp;#19981;&amp;#20877;&amp;#22788;&amp;#29702;&amp;#10;                    if (alreadyDispatchedToNewTouchTarget &amp;#38;&amp;#38; target == newTouchTarget) &amp;#123;&amp;#10;                        handled = true;&amp;#10;                    &amp;#125; else &amp;#123;&amp;#10;                        /*&amp;#10;                        *&amp;#19979;&amp;#38754;&amp;#23558;ACTION_MOVE&amp;#20107;&amp;#20214;&amp;#21644;ACTION_UP&amp;#20107;&amp;#20214;&amp;#23545;&amp;#20043;&amp;#21069;&amp;#25509;&amp;#21463;ACTION_DOWN&amp;#20107;&amp;#20214;&amp;#30340;childView&amp;#36827;&amp;#34892;&amp;#20256;&amp;#36882;&amp;#12290;&amp;#10;                        */&amp;#10;                        final boolean cancelChild = resetCancelNextUpFlag(target.child)&amp;#10;                                || intercepted;&amp;#10;                        if (dispatchTransformedTouchEvent(ev, cancelChild,&amp;#10;                                target.child, target.pointerIdBits)) &amp;#123;&amp;#10;                            handled = true;&amp;#10;                        &amp;#125;&amp;#10;                        if (cancelChild) &amp;#123;&amp;#10;                            if (predecessor == null) &amp;#123;&amp;#10;                                mFirstTouchTarget = next;&amp;#10;                            &amp;#125; else &amp;#123;&amp;#10;                                predecessor.next = next;&amp;#10;                            &amp;#125;&amp;#10;                            target.recycle();&amp;#10;                            target = next;&amp;#10;                            continue;&amp;#10;                        &amp;#125;&amp;#10;                    &amp;#125;&amp;#10;                    predecessor = target;&amp;#10;                    target = next;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            // Update list of touch targets for pointer up or cancel, if needed.&amp;#10;            if (canceled&amp;#10;                    || actionMasked == MotionEvent.ACTION_UP&amp;#10;                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &amp;#123;&amp;#10;                resetTouchState();&amp;#10;            &amp;#125; else if (split &amp;#38;&amp;#38; actionMasked == MotionEvent.ACTION_POINTER_UP) &amp;#123;&amp;#10;                final int actionIndex = ev.getActionIndex();&amp;#10;                final int idBitsToRemove = 1 &amp;#60;&amp;#60; ev.getPointerId(actionIndex);&amp;#10;                removePointersFromTouchTargets(idBitsToRemove);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        if (!handled &amp;#38;&amp;#38; mInputEventConsistencyVerifier != null) &amp;#123;&amp;#10;            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);&amp;#10;        &amp;#125;&amp;#10;        return handled;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从源码角度谈就ViewGroup的onInterceptTouchEvent方法的调用流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Cursor的close方法源码阅读</title>
    <link href="http://gonggaofeng.me/2015/07/07/Cursor%E7%9A%84close%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://gonggaofeng.me/2015/07/07/Cursor的close方法源码阅读/</id>
    <published>2015-07-07T08:24:02.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;Cursor.close会关闭与其关联的Database。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;以DownloadManager中的CursorTranslator为例。&lt;br&gt;CursorTranslator继承CursorWrapper&lt;br&gt;CursorTranslator中包裹的cursor是ContentResolver的内部类CursorWrapperInner.&lt;br&gt;CursorWrapperInner中包裹了BulkCursorToCursorAdapter&lt;br&gt;BulkCursorToCursorAdaptor将服务端返回的IBulkCursor适配成本地进程可以使用的Cursor类型。&lt;br&gt;BulkCursorToCursorAdaptor继承于AbstractWindowedCursor。&lt;br&gt;AbstractWindowedCursor有一个成员变量是mWindow（CursorWindow类型）&lt;br&gt;AbstractWindowedCursor继承与AbstractCursor，并且覆盖了onDeactivateOrClose方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Override&amp;#10;    protected void onDeactivateOrClose() &amp;#123;&amp;#10;        super.onDeactivateOrClose();&amp;#10;        closeWindow();&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;closeWindow方法的实现是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void closeWindow() &amp;#123;&amp;#10;       if (mWindow != null) &amp;#123;&amp;#10;           mWindow.close();&amp;#10;           mWindow = null;&amp;#10;       &amp;#125;&amp;#10;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;onDeactivateOrClose方法是在AbstractCursor的close方法中调用的。具体方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void close() &amp;#123;&amp;#10;        mClosed = true;&amp;#10;        mContentObservable.unregisterAll();&amp;#10;        onDeactivateOrClose();&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CursorWindow继承于SQLiteClosable，在SQLiteClosable的close方法释放当前连接。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void close() &amp;#123;&amp;#10;        releaseReference();&amp;#10;    &amp;#125;&amp;#10;    public void releaseReference() &amp;#123;&amp;#10;        boolean refCountIsZero = false;&amp;#10;        synchronized(this) &amp;#123;&amp;#10;            refCountIsZero = --mReferenceCount == 0;&amp;#10;        &amp;#125;&amp;#10;        if (refCountIsZero) &amp;#123;&amp;#10;            onAllReferencesReleased();&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CursorWindow覆盖了onAllReferencesReleased方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void onAllReferencesReleased() &amp;#123;&amp;#10;        dispose();&amp;#10;    &amp;#125;&amp;#10;    private void dispose() &amp;#123;&amp;#10;        if (mCloseGuard != null) &amp;#123;&amp;#10;            mCloseGuard.close();&amp;#10;        &amp;#125;&amp;#10;        if (mWindowPtr != 0) &amp;#123;&amp;#10;            recordClosingOfWindow(mWindowPtr);&amp;#10;            nativeDispose(mWindowPtr);&amp;#10;            mWindowPtr = 0;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Cursor.close会关闭与其关联的Database。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中继承RadioButton后，点击不能选中</title>
    <link href="http://gonggaofeng.me/2015/07/07/Android%E4%B8%AD%E7%BB%A7%E6%89%BFRadioButton%E5%90%8E%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8D%E8%83%BD%E9%80%89%E4%B8%AD/"/>
    <id>http://gonggaofeng.me/2015/07/07/Android中继承RadioButton后，点击不能选中/</id>
    <published>2015-07-07T08:21:24.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;在继承RadioButton的时候，覆改构造方法的时候要确保&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public RadioButton(Context context, AttributeSet attrs) &amp;#123;&amp;#10;        this(context, attrs, com.android.internal.R.attr.radioButtonStyle);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个构造方法被调用。必须在子类中调用super(Context context, AttributeSet attrs)方法。否则RadioButton子类不能选中。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在继承RadioButton的时候，覆改构造方法的时候要确保&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>android:fitSystemWindows源码探索</title>
    <link href="http://gonggaofeng.me/2015/07/07/android-fitSystemWindows%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/"/>
    <id>http://gonggaofeng.me/2015/07/07/android-fitSystemWindows源码探索/</id>
    <published>2015-07-07T05:06:18.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;从源码角度探究fitSystemWindows属性。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;从Android 4.4开始，Android系统加入了一个比较酷的功能，就是我们可以设置状态栏的的颜色了，有个这个功能，状态栏就不再是黑乎乎的了，我们就可以根据我们应用的主色去设置状态栏的颜色，使得应用体验变得好一些，所以我们通过如下方式设置状态栏透明。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &amp;#10;window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION, WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是设置了状态栏和导航栏透明之后，发现Activity的contentView超出了ActionBar，那么我们就要使用fitSystemWindws来解决这个问题，关于具体如何解决这个问题，在&lt;a href=&quot;http://blog.csdn.net/kobe_gong_5/article/details/41704719%20%E2%80%9CAndroid4.4%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8C%E5%9C%A8%E5%BA%94%E7%94%A8%E5%86%85%E5%BC%80%E5%90%AF%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E9%80%8F%E6%98%8E%E8%99%9A%E6%8B%9F%E6%8C%89%E9%92%AE%E2%80%9D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android4.4新的特性，在应用内开启透明状态栏和透明虚拟按钮&lt;/a&gt;这篇博客中有详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150522212938290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS29iZV9Hb25nXzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;那么android:fitSystemWindows到底是什么东西啊，它是怎样计算的？&lt;br&gt;在Android Framework的源代码中查看View.java，有这几个重要方法，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dispatchApplyWindowInsets&lt;/li&gt;
&lt;li&gt;onApplyWindowInsets&lt;/li&gt;
&lt;li&gt;fitSystemWindows&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是一个自定义的View，并且覆盖View的这三个方法，打印出Log，可以发现这三个方法的调用顺序是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dispatchApplyWindowInsets&lt;/li&gt;
&lt;li&gt;onApplyWindowInsets&lt;/li&gt;
&lt;li&gt;fitSystemWindows&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们通过代码调试的方法来查看Android Framework的方法调用堆栈，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150525005118469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS29iZV9Hb25nXzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;根据堆栈可以发现，dispatchApplyWindowInsets方法是在ViewRootImpl.performMeasure(int,int)方法中调用的。也就是说，dispatchApplyWindowInsets是在整个View Hierarchy的measure过程中调用的。&lt;/p&gt;
&lt;p&gt;在从layout文件中解释到fitSystemWindows为true设置标志位。那这个标志为在什么时候起的作用。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case com.android.internal.R.styleable.View_fitsSystemWindows:&amp;#10;                    if (a.getBoolean(attr, false)) &amp;#123;&amp;#10;                        viewFlagValues |= FITS_SYSTEM_WINDOWS;&amp;#10;                        viewFlagMasks |= FITS_SYSTEM_WINDOWS;&amp;#10;                    &amp;#125;&amp;#10;                    break;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再看上面那幅堆栈图，在ActionBarOverlayLayout.measure()中开始调用fitSystemWindows的相关方法，进入ActionBarOverlayLayout的源码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &amp;#123;&amp;#10;&amp;#9;&amp;#9;//&amp;#36890;&amp;#36807;findViewById&amp;#26041;&amp;#27861;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#24067;&amp;#23616;&amp;#25991;&amp;#20214;&amp;#20013;&amp;#30340;view&amp;#10;        pullChildren();&amp;#10;&amp;#10;        int maxHeight = 0;&amp;#10;        int maxWidth = 0;&amp;#10;        int childState = 0;&amp;#10;&amp;#10;        int topInset = 0;&amp;#10;        int bottomInset = 0;&amp;#10;&amp;#9;&amp;#9;//&amp;#27979;&amp;#37327;ActionBar&amp;#30340;&amp;#39640;&amp;#24230;&amp;#21644;&amp;#23485;&amp;#24230;&amp;#10;        measureChildWithMargins(mActionBarTop, widthMeasureSpec, 0, heightMeasureSpec, 0);&amp;#10;        LayoutParams lp = (LayoutParams) mActionBarTop.getLayoutParams();&amp;#10;        maxWidth = Math.max(maxWidth,&amp;#10;                mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);&amp;#10;        maxHeight = Math.max(maxHeight,&amp;#10;                mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);&amp;#10;        childState = ViewUtils.combineMeasuredStates(childState,&amp;#10;                ViewCompat.getMeasuredState(mActionBarTop));&amp;#10;&amp;#10;        // xlarge screen layout doesn&amp;#39;t have bottom action bar.&amp;#10;        //&amp;#27979;&amp;#37327;ActionBar&amp;#24213;&amp;#37096;&amp;#21306;&amp;#22495;&amp;#30340;&amp;#39640;&amp;#24230;&amp;#21644;&amp;#23485;&amp;#24230;&amp;#10;        if (mActionBarBottom != null) &amp;#123;&amp;#10;            measureChildWithMargins(mActionBarBottom, widthMeasureSpec, 0, heightMeasureSpec, 0);&amp;#10;            lp = (LayoutParams) mActionBarBottom.getLayoutParams();&amp;#10;            maxWidth = Math.max(maxWidth,&amp;#10;                    mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);&amp;#10;            maxHeight = Math.max(maxHeight,&amp;#10;                    mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);&amp;#10;            childState = ViewUtils.combineMeasuredStates(childState,&amp;#10;                    ViewCompat.getMeasuredState(mActionBarBottom));&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        final int vis = ViewCompat.getWindowSystemUiVisibility(this);&amp;#10;        final boolean stable = (vis &amp;#38; SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;&amp;#10;&amp;#10;        if (stable) &amp;#123;&amp;#10;            // This is the standard space needed for the action bar.  For stable measurement,&amp;#10;            // we can&amp;#39;t depend on the size currently reported by it -- this must remain constant.&amp;#10;            topInset = mActionBarHeight;&amp;#10;            //&amp;#32771;&amp;#34385;&amp;#21040;ActionbarTab&amp;#30340;&amp;#39640;&amp;#24230;&amp;#65292;&amp;#35745;&amp;#31639;topInset&amp;#10;            if (mHasNonEmbeddedTabs) &amp;#123;&amp;#10;                final View tabs = mActionBarTop.getTabContainer();&amp;#10;                if (tabs != null) &amp;#123;&amp;#10;                    // If tabs are not embedded, increase space on top to account for them.&amp;#10;                    topInset += mActionBarHeight;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; else if (mActionBarTop.getVisibility() != GONE) &amp;#123;&amp;#10;            // This is the space needed on top of the window for all of the action bar&amp;#10;            // and tabs.&amp;#10;            topInset = mActionBarTop.getMeasuredHeight();&amp;#10;        &amp;#125;&amp;#10;&amp;#9;&amp;#9;//&amp;#22914;&amp;#26524;ActionBar&amp;#26159;split&amp;#27169;&amp;#24335;&amp;#65292;&amp;#32771;&amp;#34385;&amp;#24213;&amp;#37096;&amp;#30340;&amp;#39640;&amp;#24230;&amp;#65292;&amp;#35745;&amp;#31639;insetBottom&amp;#10;        if (mDecorToolbar.isSplit()) &amp;#123;&amp;#10;            // If action bar is split, adjust bottom insets for it.&amp;#10;            if (mActionBarBottom != null) &amp;#123;&amp;#10;                if (stable) &amp;#123;&amp;#10;                    bottomInset = mActionBarHeight;&amp;#10;                &amp;#125; else &amp;#123;&amp;#10;                    bottomInset = mActionBarBottom.getMeasuredHeight();&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        // If the window has not requested system UI layout flags, we need to&amp;#10;        // make sure its content is not being covered by system UI...  though it&amp;#10;        // will still be covered by the action bar if they have requested it to&amp;#10;        // overlay.&amp;#10;        mContentInsets.set(mBaseContentInsets);&amp;#10;        mInnerInsets.set(mBaseInnerInsets);&amp;#10;        if (!mOverlayMode &amp;#38;&amp;#38; !stable) &amp;#123;&amp;#10;            mContentInsets.top += topInset;&amp;#10;            mContentInsets.bottom += bottomInset;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            mInnerInsets.top += topInset;&amp;#10;            mInnerInsets.bottom += bottomInset;&amp;#10;        &amp;#125;&amp;#10;&amp;#9;&amp;#9;//&amp;#22312;ActionBar&amp;#20026;&amp;#38750;Overlay&amp;#27169;&amp;#24335;&amp;#19979;&amp;#65292;&amp;#24212;&amp;#29992;&amp;#35745;&amp;#31639;&amp;#22909;&amp;#30340;ContentInsets&amp;#10;        applyInsets(mContent, mContentInsets, true, true, true, true);&amp;#10;&amp;#9;&amp;#9;//&amp;#10;        if (!mLastInnerInsets.equals(mInnerInsets)) &amp;#123;&amp;#10;            // If the inner insets have changed, we need to dispatch this down to&amp;#10;            // the app&amp;#39;s fitSystemWindows().  We do this before measuring the content&amp;#10;            // view to keep the same semantics as the normal fitSystemWindows() call.&amp;#10;            mLastInnerInsets.set(mInnerInsets);&amp;#10;&amp;#10;//Overlay&amp;#27169;&amp;#24335;&amp;#19979;&amp;#65292;&amp;#23558;InnerInsets&amp;#20998;&amp;#21457;&amp;#21040;&amp;#23376;View&amp;#20013;&amp;#12290;            mContent.dispatchFitSystemWindows(mInnerInsets);&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        measureChildWithMargins(mContent, widthMeasureSpec, 0, heightMeasureSpec, 0);&amp;#10;        lp = (LayoutParams) mContent.getLayoutParams();&amp;#10;        maxWidth = Math.max(maxWidth,&amp;#10;                mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);&amp;#10;        maxHeight = Math.max(maxHeight,&amp;#10;                mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);&amp;#10;        childState = ViewUtils.combineMeasuredStates(childState,&amp;#10;                ViewCompat.getMeasuredState(mContent));&amp;#10;&amp;#10;        // Account for padding too&amp;#10;        maxWidth += getPaddingLeft() + getPaddingRight();&amp;#10;        maxHeight += getPaddingTop() + getPaddingBottom();&amp;#10;&amp;#10;        // Check against our minimum height and width&amp;#10;        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());&amp;#10;        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());&amp;#10;&amp;#10;        setMeasuredDimension(&amp;#10;                ViewCompat.resolveSizeAndState(maxWidth, widthMeasureSpec, childState),&amp;#10;                ViewCompat.resolveSizeAndState(maxHeight, heightMeasureSpec,&amp;#10;                        childState &amp;#60;&amp;#60; MEASURED_HEIGHT_STATE_SHIFT));&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据上面的堆栈图知道mContent是NativeActionModeAwareLayout类型，而NativeActionModeAwareLayout，没有dispatchFitSystemWindows方法，那么查看其父类的dispatchFitSystemWindows方法。NativeActionModeAwareLayout的父类是ContentFrameLayout类型，看它的dispatchFitSystemWindows方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void dispatchFitSystemWindows(Rect insets) &amp;#123;&amp;#10;        fitSystemWindows(insets);&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它直接调用View的fitSystemWindows方法。看View的fitSystemWindows方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected boolean fitSystemWindows(Rect insets) &amp;#123;&amp;#10;        if ((mPrivateFlags3 &amp;#38; PFLAG3_APPLYING_INSETS) == 0) &amp;#123;&amp;#10;            if (insets == null) &amp;#123;&amp;#10;                // Null insets by definition have already been consumed.&amp;#10;                // This call cannot apply insets since there are none to apply,&amp;#10;                // so return false.&amp;#10;                return false;&amp;#10;            &amp;#125;&amp;#10;           &amp;#10;            try &amp;#123;&amp;#10;                mPrivateFlags3 |= PFLAG3_FITTING_SYSTEM_WINDOWS;&amp;#10;                return dispatchApplyWindowInsets(new WindowInsets(insets)).isConsumed();&amp;#10;            &amp;#125; finally &amp;#123;&amp;#10;                mPrivateFlags3 &amp;#38;= ~PFLAG3_FITTING_SYSTEM_WINDOWS;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            return fitSystemWindowsInt(insets);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于第一次调用，这里的mPrivateFlags3 的PFLAG3_APPLYING_INSETS标志为不为1，所以进入if条件。进入dispatchApplyWindowInsets方法。并将mPrivateFlags3 的PFLAG3_APPLYING_INSETS标志为置为1。由于ContentFrameLayout继承了Framelayout ,所以进入了ViewGroup的dispatchApplyWindowInsets方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Override&amp;#10;    public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) &amp;#123;&amp;#10;        insets = super.dispatchApplyWindowInsets(insets);&amp;#10;        if (!insets.isConsumed()) &amp;#123;&amp;#10;            final int count = getChildCount();&amp;#10;            for (int i = 0; i &amp;#60; count; i++) &amp;#123;&amp;#10;                insets = getChildAt(i).dispatchApplyWindowInsets(insets);&amp;#10;                if (insets.isConsumed()) &amp;#123;&amp;#10;                    break;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        return insets;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;首先调用了 super.dispatchApplyWindowInsets方法，也就是View的 dispatchApplyWindowInsets，&lt;br&gt;然后如果insets没有被消费掉的话，分别调用每个view child的dispatchApplyWindowInsets方法，让子view去消费它，如果子view消费了，那么到此结束。先执行 super.dispatchApplyWindowInsets方法。&lt;br&gt;下面是View.dispatchApplyWindowInsets方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) &amp;#123;&amp;#10;       try &amp;#123;&amp;#10;           mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;&amp;#10;           if (mListenerInfo != null &amp;#38;&amp;#38; mListenerInfo.mOnApplyWindowInsetsListener != null) &amp;#123;&amp;#10;               return mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(this, insets);&amp;#10;           &amp;#125; else &amp;#123;&amp;#10;               return onApplyWindowInsets(insets);&amp;#10;           &amp;#125;&amp;#10;       &amp;#125; finally &amp;#123;&amp;#10;           mPrivateFlags3 &amp;#38;= ~PFLAG3_APPLYING_INSETS;&amp;#10;       &amp;#125;&amp;#10;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在此方法中首先将mPrivateFlags3 的PFLAG3_APPLYING_INSETS标志位置为1，然后如果开发者设置了listener的话就调用listener，否则调用onApplyWindowInsets方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public WindowInsets onApplyWindowInsets(WindowInsets insets) &amp;#123;&amp;#10;        if ((mPrivateFlags3 &amp;#38; PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) &amp;#123;&amp;#10;            if (fitSystemWindows(insets.getSystemWindowInsets())) &amp;#123;&amp;#10;                return insets.consumeSystemWindowInsets();&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            if (fitSystemWindowsInt(insets.getSystemWindowInsets())) &amp;#123;&amp;#10;                return insets.consumeSystemWindowInsets();&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        return insets;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在第一次调用fitSystemWindows方法后，mPrivateFlags3 得 PFLAG3_FITTING_SYSTEM_WINDOWS标志为被置位1了，所以进入fitSystemWindowsInt方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private boolean fitSystemWindowsInt(Rect insets) &amp;#123;&amp;#10;        if ((mViewFlags &amp;#38; FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) &amp;#123;&amp;#10;            mUserPaddingStart = UNDEFINED_PADDING;&amp;#10;            mUserPaddingEnd = UNDEFINED_PADDING;&amp;#10;            Rect localInsets = sThreadLocal.get();&amp;#10;            if (localInsets == null) &amp;#123;&amp;#10;                localInsets = new Rect();&amp;#10;                sThreadLocal.set(localInsets);&amp;#10;            &amp;#125;&amp;#10;            boolean res = computeFitSystemWindows(insets, localInsets);&amp;#10;            mUserPaddingLeftInitial = localInsets.left;&amp;#10;            mUserPaddingRightInitial = localInsets.right;&amp;#10;            internalSetPadding(localInsets.left, localInsets.top,&amp;#10;                    localInsets.right, localInsets.bottom);&amp;#10;            return res;&amp;#10;        &amp;#125;&amp;#10;        return false;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个方法中，两个关键函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;computeFitSystemWindows&lt;/li&gt;
&lt;li&gt;internalSetPadding&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看computeFitSystemWindows。官方解释是，计算insets应该被此view消费掉还是继续传递。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected boolean computeFitSystemWindows(Rect inoutInsets, Rect outLocalInsets) &amp;#123;&amp;#10;        if ((mViewFlags &amp;#38; OPTIONAL_FITS_SYSTEM_WINDOWS) == 0&amp;#10;                || mAttachInfo == null&amp;#10;                || ((mAttachInfo.mSystemUiVisibility &amp;#38; SYSTEM_UI_LAYOUT_FLAGS) == 0&amp;#10;                        &amp;#38;&amp;#38; !mAttachInfo.mOverscanRequested)) &amp;#123;&amp;#10;            outLocalInsets.set(inoutInsets);&amp;#10;            inoutInsets.set(0, 0, 0, 0);&amp;#10;            return true;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            // The application wants to take care of fitting system window for&amp;#10;            // the content...  however we still need to take care of any overscan here.&amp;#10;            final Rect overscan = mAttachInfo.mOverscanInsets;&amp;#10;            outLocalInsets.set(overscan);&amp;#10;            inoutInsets.left -= overscan.left;&amp;#10;            inoutInsets.top -= overscan.top;&amp;#10;            inoutInsets.right -= overscan.right;&amp;#10;            inoutInsets.bottom -= overscan.bottom;&amp;#10;            return false;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再看internalSetPadding&lt;br&gt;此方法是设置view的padding。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected void internalSetPadding(int left, int top, int right, int bottom) &amp;#123;&amp;#10;       mUserPaddingLeft = left;&amp;#10;       mUserPaddingRight = right;&amp;#10;       mUserPaddingBottom = bottom;&amp;#10;&amp;#10;       final int viewFlags = mViewFlags;&amp;#10;       boolean changed = false;&amp;#10;&amp;#10;       // Common case is there are no scroll bars.&amp;#10;       if ((viewFlags &amp;#38; (SCROLLBARS_VERTICAL|SCROLLBARS_HORIZONTAL)) != 0) &amp;#123;&amp;#10;           if ((viewFlags &amp;#38; SCROLLBARS_VERTICAL) != 0) &amp;#123;&amp;#10;               final int offset = (viewFlags &amp;#38; SCROLLBARS_INSET_MASK) == 0&amp;#10;                       ? 0 : getVerticalScrollbarWidth();&amp;#10;               switch (mVerticalScrollbarPosition) &amp;#123;&amp;#10;                   case SCROLLBAR_POSITION_DEFAULT:&amp;#10;                       if (isLayoutRtl()) &amp;#123;&amp;#10;                           left += offset;&amp;#10;                       &amp;#125; else &amp;#123;&amp;#10;                           right += offset;&amp;#10;                       &amp;#125;&amp;#10;                       break;&amp;#10;                   case SCROLLBAR_POSITION_RIGHT:&amp;#10;                       right += offset;&amp;#10;                       break;&amp;#10;                   case SCROLLBAR_POSITION_LEFT:&amp;#10;                       left += offset;&amp;#10;                       break;&amp;#10;               &amp;#125;&amp;#10;           &amp;#125;&amp;#10;           if ((viewFlags &amp;#38; SCROLLBARS_HORIZONTAL) != 0) &amp;#123;&amp;#10;               bottom += (viewFlags &amp;#38; SCROLLBARS_INSET_MASK) == 0&amp;#10;                       ? 0 : getHorizontalScrollbarHeight();&amp;#10;           &amp;#125;&amp;#10;       &amp;#125;&amp;#10;&amp;#10;       if (mPaddingLeft != left) &amp;#123;&amp;#10;           changed = true;&amp;#10;           mPaddingLeft = left;&amp;#10;       &amp;#125;&amp;#10;       if (mPaddingTop != top) &amp;#123;&amp;#10;           changed = true;&amp;#10;           mPaddingTop = top;&amp;#10;       &amp;#125;&amp;#10;       if (mPaddingRight != right) &amp;#123;&amp;#10;           changed = true;&amp;#10;           mPaddingRight = right;&amp;#10;       &amp;#125;&amp;#10;       if (mPaddingBottom != bottom) &amp;#123;&amp;#10;           changed = true;&amp;#10;           mPaddingBottom = bottom;&amp;#10;       &amp;#125;&amp;#10;&amp;#10;       if (changed) &amp;#123;&amp;#10;           requestLayout();&amp;#10;       &amp;#125;&amp;#10;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从源码角度探究fitSystemWindows属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中的信使Messenger</title>
    <link href="http://gonggaofeng.me/2015/07/07/Android%E4%B8%AD%E7%9A%84%E4%BF%A1%E4%BD%BFMessenger/"/>
    <id>http://gonggaofeng.me/2015/07/07/Android中的信使Messenger/</id>
    <published>2015-07-07T01:20:58.000Z</published>
    <updated>2016-03-28T15:28:57.000Z</updated>
    
    <content type="html">&lt;p&gt;通过Messenger可以实现基于message的IPC通信。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Messenger内部引用了一个Handler，通过Messenger的getBinder方法返回一个IBinder对象，客户端通过bindServer方法绑定到Service时候得到IBinder对象，通过&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Messenger messenger = IMesssenger.Stub.asInterface(IBinder)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过IBinder得到服务端的代理Messenger对象，通过该对象可以实现IPC通信。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public IBinder getBinder() &amp;#123;&amp;#10;        return mTarget.asBinder();&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;mTarget是IMessenger类型。在Messenger的构造方法中对mTarget进行了初始化。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public Messenger(Handler target) &amp;#123;&amp;#10;       mTarget = target.getIMessenger();&amp;#10;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过调用Handler的getIMessenger方法得到mTarget。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;final IMessenger getIMessenger() &amp;#123;&amp;#10;        synchronized (mQueue) &amp;#123;&amp;#10;            if (mMessenger != null) &amp;#123;&amp;#10;                return mMessenger;&amp;#10;            &amp;#125;&amp;#10;            mMessenger = new MessengerImpl();&amp;#10;            return mMessenger;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;mMessenger是Handler内部类MessengerImpl的一个实例。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private final class MessengerImpl extends IMessenger.Stub &amp;#123;&amp;#10;        public void send(Message msg) &amp;#123;&amp;#10;            msg.sendingUid = Binder.getCallingUid();&amp;#10;            Handler.this.sendMessage(msg);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Binder.getCallingUid()方法返回发送当前正在处理的这个事务的进程uid。&lt;br&gt;通过handler的sendMessage将该消息发送到当前线程的消息队列中。&lt;/p&gt;
&lt;p&gt;总结：Messenger实现了Parcelable接口，我们可以在服务端将Messenger作为IBinder返回给客户端，客户端将IBinder转成IMessenger类型，通过调用IMessenger的send()方法向服务端发送Message。&lt;br&gt;android.os.MessengerService实现了基于Messenger通信的Service。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通过Messenger可以实现基于message的IPC通信。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://gonggaofeng.me/tags/Android/"/>
    
  </entry>
  
</feed>
